<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluentify - Modern AI Translator</title>

    <meta name="theme-color" content="#1e293b">
    <meta name="description" content="Translate text, images, and PDF documents with a modern, fast, and user-friendly interface powered by Google AI.">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style type="text/css">
        body, .bg-card, .bg-input { transition: background-color 0.3s ease, color 0.3s ease; }
        textarea::-webkit-scrollbar, .scroll-container::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track, .scroll-container::-webkit-scrollbar-track { background: transparent; }
        textarea::-webkit-scrollbar-thumb, .scroll-container::-webkit-scrollbar-thumb { background-color: rgba(100, 116, 139, 0.5); border-radius: 20px; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .spinner { animation: spin 1s linear infinite; }
        .pdf-page-item { transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .pdf-page-item.selected {
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.5);
        }
        .pdf-page-item.selected::after {
            content: '✔';
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #0ea5e9;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        #enhancements-toolbar { transition: opacity 0.3s ease, transform 0.3s ease; }
        
        /* New Styles */
        .progress-bar { height: 8px; background-color: #e5e7eb; border-radius: 9999px; overflow: hidden; }
        .dark .progress-bar { background-color: #374151; }
        .progress-bar-inner { height: 100%; background-color: #0ea5e9; border-radius: 9999px; transition: width 0.3s ease; }

        #log-viewer { transition: max-height 0.5s ease-in-out; }
        #log-output { white-space: pre-wrap; word-break: break-all; }
        .log-entry { display: flex; gap: 0.75rem; }
        .log-timestamp { flex-shrink: 0; color: #64748b; }
        .dark .log-timestamp { color: #94a3b8; }
        .log-message.error { color: #ef4444; }
        .dark .log-message.error { color: #f87171; }
        .log-message.success { color: #22c55e; }
        .dark .log-message.success { color: #4ade80; }

        #subtitle-editor-section table { width: 100%; border-collapse: collapse; }
        #subtitle-editor-section th, #subtitle-editor-section td { padding: 8px 12px; border: 1px solid #d1d5db; text-align: left; vertical-align: middle;}
        html[dir="rtl"] #subtitle-editor-section th, html[dir="rtl"] #subtitle-editor-section td { text-align: right; }
        .dark #subtitle-editor-section th, .dark #subtitle-editor-section td { border-color: #4b5563; }
        #subtitle-editor-section th { background-color: #f3f4f6; }
        .dark #subtitle-editor-section th { background-color: #374151; }
        #subtitle-editor-section td:nth-child(3), #subtitle-editor-section td:nth-child(4) { font-size: 0.9rem; }
        #subtitle-editor-section .translated-text { background-color: #f0f9ff; }
        .dark #subtitle-editor-section .translated-text { background-color: #1e293b; }

        #subtitle-editor-section td[contenteditable="true"] {
            outline: 2px solid transparent;
            transition: background-color 0.2s ease, outline-color 0.2s ease;
        }
        #subtitle-editor-section td[contenteditable="true"]:focus {
            background-color: #f0f9ff;
            outline-color: #0ea5e9;
        }
        .dark #subtitle-editor-section td[contenteditable="true"]:focus {
            background-color: #0c4a6e;
        }
        #subtitle-editor-section mark {
            background-color: #fde047;
            color: #1e293b;
            padding: 1px 2px;
            border-radius: 3px;
        }
        .dark #subtitle-editor-section mark {
            background-color: #facc15;
        }
    </style>
</head>

<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-300 font-sans antialiased flex flex-col items-center justify-center min-h-screen p-4">

    <main class="w-full max-w-4xl mx-auto">


        <div id="app-container" class="bg-white dark:bg-slate-800 bg-card rounded-2xl shadow-lg dark:shadow-2xl dark:shadow-black/30 p-6 md:p-8 relative overflow-hidden">
            
            <header class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-slate-900 dark:text-white" data-i18n-key="appTitle">Fluentify</h1>
                <div class="flex items-center gap-2">
                    <select id="language-switcher" class="bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-300 rounded-md p-2 text-sm focus:ring-2 focus:ring-sky-500 focus:outline-none appearance-none cursor-pointer">
                        <option value="en">English</option>
                        <option value="fa">فارسی</option>
                        <option value="ru">Русский</option>
                    </select>
                    <button id="how-to-use-btn" class="p-2 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors" data-i18n-title-key="howToUseBtnLabel" aria-label="How to use">
                        <svg class="w-5 h-5 text-slate-600 dark:text-slate-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z" /></svg>
                    </button>
                    <button id="theme-toggle" class="p-2 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors" aria-label="Toggle theme">
                        <svg id="theme-icon-light" class="w-5 h-5 text-amber-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                        <svg id="theme-icon-dark" class="w-5 h-5 text-slate-400 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                    </button>
                </div>
            </header>

            <form id="translate-form" onsubmit="return false;">
                <div class="flex items-center space-x-2 rtl:space-x-reverse mb-4 bg-slate-200 dark:bg-slate-700 p-1 rounded-lg">
                    <label class="flex-1 text-center py-2 px-3 rounded-md cursor-pointer transition-colors has-[:checked]:bg-sky-500 has-[:checked]:text-white text-slate-600 dark:text-slate-300">
                        <input type="radio" name="input_type" value="text" class="sr-only" checked> <span data-i18n-key="tabText">Text</span>
                    </label>
                    <label class="flex-1 text-center py-2 px-3 rounded-md cursor-pointer transition-colors has-[:checked]:bg-sky-500 has-[:checked]:text-white text-slate-600 dark:text-slate-300">
                        <input type="radio" name="input_type" value="image" class="sr-only"> <span data-i18n-key="tabImage">Image</span>
                    </label>
                    <label class="flex-1 text-center py-2 px-3 rounded-md cursor-pointer transition-colors has-[:checked]:bg-sky-500 has-[:checked]:text-white text-slate-600 dark:text-slate-300">
                        <input type="radio" name="input_type" value="pdf" class="sr-only"> <span data-i18n-key="tabPDF">PDF</span>
                    </label>
                    <label class="flex-1 text-center py-2 px-3 rounded-md cursor-pointer transition-colors has-[:checked]:bg-sky-500 has-[:checked]:text-white text-slate-600 dark:text-slate-300">
                        <input type="radio" name="input_type" value="subtitle" class="sr-only"> <span data-i18n-key="tabSubtitle">Subtitle</span>
                    </label>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-[1fr_auto_1fr] gap-4 items-center mb-4">
                    <select id="source_lang" name="source_lang" class="w-full bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 rounded-lg p-3"></select>
                    <button type="button" id="swap-btn" class="p-3 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed md:mx-0 mx-auto" data-i18n-title-key="swapBtnLabel" aria-label="Swap languages">
                        <svg class="w-5 h-5 text-slate-600 dark:text-slate-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" /></svg>
                    </button>
                    <select id="target_lang" name="target_lang" class="w-full bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 rounded-lg p-3"></select>
                </div>

                <div class="relative mb-4">
                    <div id="text-input-container">
                        <textarea id="text-input" name="text" maxlength="5000" data-i18n-placeholder-key="textInputPlaceholder" placeholder="Enter text to translate..." class="w-full h-40 p-4 bg-slate-100 dark:bg-slate-700 bg-input rounded-lg border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 resize-none"></textarea>
                        <span id="char-counter" class="absolute bottom-2 right-3 rtl:right-auto rtl:left-3 text-xs text-slate-500 dark:text-slate-400">0 / 5000</span>
                    </div>

                    <div id="youtube-input-section" class="hidden mb-4 p-4 bg-slate-200/50 dark:bg-slate-900/50 rounded-lg space-y-3">
                         <label class="block text-sm font-medium text-slate-700 dark:text-slate-300" data-i18n-key="youtubeSectionTitle">Load from YouTube URL</label>
                         <div class="flex flex-col sm:flex-row gap-2">
                             <input type="text" id="youtube-url-input" data-i18n-placeholder-key="youtubeUrlPlaceholder" placeholder="Enter YouTube Video URL..." class="w-full flex-grow bg-slate-100 dark:bg-slate-700 bg-input rounded-lg p-3 border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 transition duration-200">
                             <input type="text" id="youtube-lang-input" value="en" data-i18n-placeholder-key="youtubeLangPlaceholder" placeholder="lang" class="sm:w-20 bg-slate-100 dark:bg-slate-700 bg-input text-center rounded-lg p-3 border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 transition duration-200">
                             <button type="button" id="fetch-youtube-subs-btn" class="w-full sm:w-auto px-4 py-2 rounded-lg bg-sky-500 hover:bg-sky-600 text-white font-bold transition-colors flex items-center justify-center">
                                <span id="fetch-youtube-btn-text" data-i18n-key="youtubeFetchBtn">Fetch</span>
                                <svg id="fetch-youtube-btn-spinner" class="spinner w-5 h-5 ml-2 rtl:ml-0 rtl:mr-2 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                             </button>
                         </div>
                         <p class="text-xs text-slate-600 dark:text-slate-400 text-center pt-3 border-t border-slate-300 dark:border-slate-700" data-i18n-key="youtubeNotice" data-i18n-html>
                            For much better subtitles than auto-generated ones for YouTube, try our new service: 
                            <a href="https://ytsrt.pages.dev" target="_blank" rel="noopener noreferrer" class="font-semibold underline text-sky-600 dark:text-sky-400 hover:text-sky-500 dark:hover:text-sky-300">YTSRT</a>.
                        </p>
                    </div>
                    
                    <div id="file-input-section" class="hidden">
                        <div id="dropzone-container" class="relative flex flex-col items-center justify-center w-full h-40 border-2 border-slate-300 dark:border-slate-600 border-dashed rounded-lg cursor-pointer bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 transition-colors p-2">
                            <div id="dropzone-prompt" class="flex flex-col items-center justify-center text-center p-4">
                                <svg class="w-8 h-8 mb-4 text-slate-500 dark:text-slate-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/></svg>
                                <p class="mb-2 text-sm text-slate-500 dark:text-slate-400"><span class="font-semibold" data-i18n-key="fileDragDrop">Drag & drop a file</span> <span data-i18n-key="fileOr">or</span></p>
                                <button type="button" id="choose-file-btn" class="px-4 py-2 bg-white dark:bg-slate-600 border border-gray-300 dark:border-gray-500 rounded-lg text-sm font-medium hover:bg-gray-100 dark:hover:bg-gray-700" data-i18n-key="fileChooseBtn">Choose File</button>
                                <p id="file-upload-hint" class="text-xs text-slate-500 mt-2">PNG, JPG, etc.</p>
                            </div>
                            <div id="file-preview-container" class="hidden relative w-full h-full flex items-center justify-center">
                                <img id="image-preview" class="max-w-full max-h-full object-contain rounded-md" alt="Image preview">
                                <div id="subtitle-preview" class="hidden text-center p-4">
                                    <svg class="w-12 h-12 mx-auto text-slate-500 dark:text-slate-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
                                    </svg>
                                    <p id="subtitle-filename" class="mt-2 font-semibold text-slate-700 dark:text-slate-300 truncate"></p>
                                </div>
                                <button type="button" id="remove-file-btn" class="absolute top-1 right-1 rtl:right-auto rtl:left-1 p-1.5 rounded-full bg-black/50 hover:bg-red-600 text-white transition-colors" data-i18n-title-key="removeFileBtnLabel" aria-label="Remove file">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                                </button>
                            </div>
                        </div>
                        <input id="file-upload" name="file" type="file" class="hidden" />
                    </div>
                </div>

                <div id="pdf-viewer-section" class="hidden mb-4 bg-slate-200/50 dark:bg-slate-900/50 rounded-lg p-4 space-y-4">
                    <div class="flex flex-wrap gap-4 justify-between items-center pb-3 border-b border-slate-300 dark:border-slate-700">
                        <h3 class="text-lg font-semibold text-slate-800 dark:text-slate-200" data-i18n-key="pdfSelectPagesTitle">Select Pages to Translate</h3>
                        <div class="flex items-center gap-2">
                             <button type="button" id="select-all-pages-btn" class="px-3 py-1 text-sm font-medium rounded-md bg-white dark:bg-slate-600 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700" data-i18n-key="pdfSelectAll">Select All</button>
                             <button type="button" id="deselect-all-pages-btn" class="px-3 py-1 text-sm font-medium rounded-md bg-white dark:bg-slate-600 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700" data-i18n-key="pdfDeselectAll">Deselect All</button>
                        </div>
                    </div>
                    <div id="pdf-page-viewer" class="scroll-container max-h-[30rem] overflow-y-auto grid grid-cols-1 md:grid-cols-2 gap-4 p-2 bg-slate-100 dark:bg-slate-800 rounded-md">
                        <!-- PDF pages will be rendered here -->
                    </div>
                     <div class="pt-3 border-t border-slate-300 dark:border-slate-700 flex flex-wrap gap-x-4 gap-y-2 justify-between items-center">
                        <span id="page-selection-counter" class="text-sm font-medium text-slate-600 dark:text-slate-400">0 pages selected</span>
                        <div class="flex items-center">
                            <input id="combine-pages-checkbox" name="combine_pages" type="checkbox" class="h-4 w-4 rounded border-slate-400 dark:border-slate-600 bg-slate-200 dark:bg-slate-700 text-sky-600 focus:ring-sky-500">
                            <label for="combine-pages-checkbox" class="ml-2 rtl:ml-0 rtl:mr-2 block text-sm font-medium text-slate-600 dark:text-slate-400" data-i18n-key="pdfCombinePages">Combine selected pages before translation</label>
                        </div>
                    </div>
                     <p id="batch-warning" class="text-xs text-amber-600 dark:text-amber-400 text-center mt-2 h-4"></p>
                </div>
                
                <div id="subtitle-editor-section" class="hidden mb-4 bg-slate-200/50 dark:bg-slate-900/50 rounded-lg p-4 space-y-4">
                    <div class="flex flex-wrap gap-4 justify-between items-center pb-3 border-b border-slate-300 dark:border-slate-700">
                        <h3 class="text-lg font-semibold text-slate-800 dark:text-slate-200" data-i18n-key="subtitleEditorTitle">Subtitle Editor</h3>
                        <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                            <div class="flex items-center gap-2">
                                <label for="subtitle-batch-size" class="text-sm font-medium text-slate-600 dark:text-slate-400 whitespace-nowrap" data-i18n-key="subtitleLinesPerRequest">Lines / Request</label>
                                <input type="number" id="subtitle-batch-size" value="250" min="1" step="1" class="w-20 p-2 text-center bg-slate-100 dark:bg-slate-700 bg-input rounded-lg border-slate-300 dark:border-transparent text-sm focus:ring-2 focus:ring-sky-500">
                            </div>
                            <div class="flex items-center gap-2">
                                 <button type="button" id="break-lines-toggle-btn" class="p-2 rounded-full bg-slate-300 dark:bg-slate-700 hover:bg-slate-400 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled data-i18n-title-key="subtitleBreakLinesBtnLabel" title="Break Long Lines" aria-label="Break Long Lines">
                                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.75 8.25l4.5 4.5m0 0l4.5 4.5m-4.5-4.5L5.25 12.75m14.25-4.5l-4.5 4.5m4.5-4.5l-4.5-4.5M5.25 12.75l4.5-4.5" /></svg>
                                </button>
                                 <button type="button" id="find-replace-toggle-btn" class="p-2 rounded-full bg-slate-300 dark:bg-slate-700 hover:bg-slate-400 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled data-i18n-title-key="subtitleFindReplaceBtnLabel" title="Find & Replace" aria-label="Find & Replace">
                                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" /></svg>
                                </button>
                                 <button type="button" id="export-btn" class="p-2 rounded-full bg-slate-300 dark:bg-slate-700 hover:bg-slate-400 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled data-i18n-title-key="subtitleExportBtnLabel" title="Export as subtitle file" aria-label="Export as subtitle file">
                                   <svg id="export-icon-default" class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
                                </button>
                                <button type="button" id="translate-all-subs-btn" class="px-4 py-2 text-sm font-bold rounded-md bg-sky-500 hover:bg-sky-600 text-white transition-colors" data-i18n-key="subtitleTranslateAll">Translate All</button>
                            </div>
                        </div>
                    </div>

                    <div id="saved-progress-notification" class="hidden p-3 my-2 bg-sky-100 dark:bg-sky-900/50 border border-sky-300 dark:border-sky-700 rounded-md flex flex-col sm:flex-row justify-between items-center gap-2">
                        <p class="text-sm font-medium text-sky-800 dark:text-sky-200" data-i18n-key="subtitleSavedProgress">Saved progress found for this file.</p>
                        <div class="flex-shrink-0">
                            <button type="button" id="load-progress-btn" class="px-3 py-1.5 text-xs font-bold rounded-md bg-sky-500 hover:bg-sky-600 text-white transition-colors" data-i18n-key="subtitleLoadProgress">Load Progress</button>
                            <button type="button" id="clear-progress-btn" class="ml-2 rtl:ml-0 rtl:mr-2 px-3 py-1.5 text-xs font-medium rounded-md bg-white dark:bg-slate-600 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700" data-i18n-key="subtitleClearHistory">Clear History</button>
                        </div>
                    </div>

                    <div id="break-lines-panel" class="hidden p-3 my-2 bg-slate-300/50 dark:bg-slate-800/50 rounded-md">
                        <div class="flex flex-wrap items-center justify-between gap-4">
                            <div class="flex items-center gap-2">
                                <label for="break-lines-max-chars" class="text-sm font-medium whitespace-nowrap" data-i18n-key="breakLinesPanelTitle">Max chars / line:</label>
                                <input type="number" id="break-lines-max-chars" value="42" min="10" step="1" class="w-20 p-2 text-center bg-slate-100 dark:bg-slate-700 bg-input rounded-lg border-slate-300 dark:border-transparent text-sm focus:ring-2 focus:ring-sky-500">
                            </div>
                            <button type="button" id="break-lines-apply-btn" class="px-4 py-2 text-sm font-bold rounded-md bg-sky-500 hover:bg-sky-600 text-white transition-colors" data-i18n-key="breakLinesApply">Apply Changes</button>
                        </div>
                    </div>
                    <div id="find-replace-panel" class="hidden p-3 my-2 bg-slate-300/50 dark:bg-slate-800/50 rounded-md space-y-3">
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                            <input type="text" id="find-input" data-i18n-placeholder-key="findInputPlaceholder" placeholder="Find text..." class="w-full bg-slate-100 dark:bg-slate-700 bg-input rounded-lg p-2 border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 transition duration-200">
                            <input type="text" id="replace-input" data-i18n-placeholder-key="replaceInputPlaceholder" placeholder="Replace with..." class="w-full bg-slate-100 dark:bg-slate-700 bg-input rounded-lg p-2 border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 transition duration-200">
                        </div>
                        <div class="flex flex-wrap items-center justify-between gap-4">
                            <div class="flex items-center gap-4">
                                <label class="flex items-center text-sm"><input type="checkbox" id="find-case-sensitive" class="h-4 w-4 rounded border-slate-400 dark:border-slate-600 bg-slate-200 dark:bg-slate-700 text-sky-600 focus:ring-sky-500 mr-1.5 rtl:mr-0 rtl:ml-1.5"> <span data-i18n-key="findCaseSensitive">Case Sensitive</span></label>
                            </div>
                            <button type="button" id="replace-all-btn" class="px-4 py-2 text-sm font-bold rounded-md bg-sky-500 hover:bg-sky-600 text-white transition-colors" data-i18n-key="replaceAllBtn">Replace All</button>
                        </div>
                    </div>
                    
                    <div class="scroll-container max-h-[30rem] overflow-auto">
                        <table id="subtitle-table">
                            <thead class="sticky top-0 bg-slate-200 dark:bg-slate-700">
                                <tr>
                                    <th class="w-12" data-i18n-key="subtitleTableHeaderNum">#</th>
                                    <th class="w-40" data-i18n-key="subtitleTableHeaderTime">Timestamp</th>
                                    <th data-i18n-key="subtitleTableHeaderOrig">Original Text</th>
                                    <th data-i18n-key="subtitleTableHeaderTrans">Translated Text</th>
                                    <th class="w-24" data-i18n-key="subtitleTableHeaderAction">Action</th>
                                </tr>
                            </thead>
                            <tbody id="subtitle-table-body">
                                <!-- Subtitle rows will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <div id="progress-container" class="hidden my-4 p-4 bg-slate-200/50 dark:bg-slate-900/50 rounded-lg space-y-3">
                    <div class="flex justify-between items-center mb-1">
                        <span id="progress-label" class="text-sm font-medium text-slate-700 dark:text-slate-300">Translating...</span>
                        <span id="progress-percentage" class="text-sm font-bold text-sky-600 dark:text-sky-400">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progress-bar-inner" class="progress-bar-inner" style="width: 0%;"></div>
                    </div>
                    <button type="button" id="cancel-translation-btn" class="w-full mt-2 px-4 py-2 text-sm font-medium rounded-md bg-red-500 hover:bg-red-600 text-white transition-colors" data-i18n-key="progressCancel">Cancel</button>
                </div>


                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <button type="button" id="settings-toggle-btn" class="w-full text-center py-3 px-4 rounded-lg bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-slate-700 dark:text-slate-200 transition-colors font-medium" data-i18n-key="advSettingsBtn">Advanced Settings</button>
                    <button type="submit" id="translate-btn" class="w-full text-center py-3 px-4 rounded-lg bg-sky-500 hover:bg-sky-600 text-white font-bold transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                        <span id="translate-btn-text" data-i18n-key="translateBtn">Translate</span>
                        <svg id="translate-btn-spinner" class="spinner w-5 h-5 ml-2 rtl:ml-0 rtl:mr-2 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    </button>
                </div>
                
                <div id="settings-panel" class="hidden space-y-4 p-4 bg-slate-200/50 dark:bg-slate-900/50 rounded-lg mb-4">
                    <div>
                        <label for="model" class="block text-sm font-medium text-slate-600 dark:text-slate-400 mb-1" data-i18n-key="settingsModel">AI Model</label>
                        <select id="model" name="model" class="w-full bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 rounded-lg p-3"></select>
                    </div>
                    <div>
                        <label for="job_field" class="block text-sm font-medium text-slate-600 dark:text-slate-400 mb-1" data-i18n-key="settingsSpecialization">Translation Specialization</label>
                        <select id="job_field" name="job_field" class="w-full bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 rounded-lg p-3"></select>
                    </div>
                    <div>
                        <label for="translation_tone" class="block text-sm font-medium text-slate-600 dark:text-slate-400 mb-1" data-i18n-key="settingsTone">Translation Tone</label>
                        <select id="translation_tone" name="translation_tone" class="w-full bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 rounded-lg p-3"></select>
                    </div>
                    <div id="custom-tone-container" class="hidden">
                         <label for="custom-tone-input" class="block text-sm font-medium text-slate-600 dark:text-slate-400 mb-1" data-i18n-key="settingsCustomToneLabel">Custom Tone Instruction</label>
                         <textarea id="custom-tone-input" data-i18n-placeholder-key="settingsCustomTonePlaceholder" placeholder="e.g., 'Translate this in the style of a pirate.'" class="w-full h-20 p-2.5 bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent text-sm rounded-lg focus:ring-2 focus:ring-sky-500"></textarea>
                    </div>
                    <div>
                        <label for="temperature" class="flex justify-between text-sm font-medium text-slate-600 dark:text-slate-400 mb-1">
                            <span data-i18n-key="settingsCreativity">Creativity (Temperature)</span>
                            <span id="temperature-value">0.7</span>
                        </label>
                        <input type="range" id="temperature" name="temperature" min="0" max="1" step="0.1" value="0.7" class="w-full h-2 bg-slate-300 rounded-lg appearance-none cursor-pointer dark:bg-slate-600">
                    </div>
                     <div>
                        <label for="request_delay" class="block text-sm font-medium text-slate-600 dark:text-slate-400 mb-1" data-i18n-key="settingsRequestDelay">Request Delay (seconds)</label>
                        <input type="number" id="request_delay" name="request_delay" min="0" step="0.1" value="4" class="w-full p-2.5 bg-slate-100 dark:bg-slate-700 bg-input rounded-lg border-slate-300 dark:border-transparent text-sm focus:ring-2 focus:ring-sky-500">
                    </div>
                    <div>
                        <label for="api_key" class="block text-sm font-medium text-slate-600 dark:text-slate-400 mb-1" data-i18n-key="settingsApiKey">Google AI API Key(s)</label>
                        <textarea id="api_key" name="api_key" data-i18n-placeholder-key="settingsApiKeyPlaceholder" placeholder="Enter your API Keys, one per line." class="w-full p-3 h-24 bg-slate-100 dark:bg-slate-700 bg-input rounded-lg border-slate-300 dark:border-transparent focus:ring-2 focus:ring-sky-500 resize-y"></textarea>
                        <p class="text-xs text-slate-500 dark:text-slate-500 mt-1" data-i18n-key="settingsApiKeyHint">Enter multiple keys to distribute load or as backups.</p>
                    </div>
                    <div class="space-y-2 pt-2 border-t border-slate-300 dark:border-slate-700">
                        <div class="flex items-center">
                            <input id="use-proxy-checkbox" name="use_proxy" type="checkbox" class="h-4 w-4 rounded border-slate-400 dark:border-slate-600 bg-slate-200 dark:bg-slate-700 text-sky-600 focus:ring-sky-500">
                            <label for="use-proxy-checkbox" class="ml-2 rtl:ml-0 rtl:mr-2 block text-sm font-medium text-slate-600 dark:text-slate-400" data-i18n-key="settingsUseProxy">Use Proxy</label>
                        </div>
                        <div id="custom-proxy-container" class="hidden">
                            <label for="custom-proxy-input" class="block text-sm font-medium text-slate-600 dark:text-slate-400" data-i18n-key="settingsCustomProxyLabel">Custom Proxy URL (Optional)</label>
                            <input type="url" id="custom-proxy-input" name="custom_proxy_url" placeholder="https://your-proxy.workers.dev/" class="mt-1 w-full p-2.5 bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent text-sm rounded-lg focus:ring-2 focus:ring-sky-500">
                            <p class="text-xs text-slate-500 dark:text-slate-500 mt-1" data-i18n-key="settingsCustomProxyHint" data-i18n-html>Deploy your own proxy using <a href="https://github.com/yebekhe/middleman" target="_blank" rel="noopener noreferrer" class="underline hover:text-sky-500">Middleman</a>.</p>
                        </div>
                    </div>
                    <div class="space-y-2 pt-2 border-t border-slate-300 dark:border-slate-700">
                        <div class="flex items-center">
                            <input id="use-custom-prompt-checkbox" type="checkbox" class="h-4 w-4 rounded border-slate-400 dark:border-slate-600 bg-slate-200 dark:bg-slate-700 text-sky-600 focus:ring-sky-500">
                            <label for="use-custom-prompt-checkbox" class="ml-2 rtl:ml-0 rtl:mr-2 block text-sm font-medium text-slate-600 dark:text-slate-400" data-i18n-key="settingsUseCustomPrompt">Use Custom Prompt</label>
                        </div>
                        <div id="custom-prompt-container" class="hidden space-y-2">
                            <textarea id="custom-prompt-input" data-i18n-placeholder-key="settingsCustomPromptPlaceholder" placeholder="Enter your custom prompt. Use {text}, {source_lang}, and {target_lang} as placeholders." class="w-full h-28 p-2.5 bg-slate-100 dark:bg-slate-700 bg-input border-slate-300 dark:border-transparent text-sm rounded-lg focus:ring-2 focus:ring-sky-500"></textarea>
                            <button type="button" id="optimize-prompt-btn" class="w-full flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md bg-white dark:bg-slate-600 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700">
                                <i class="fas fa-magic mr-2 rtl:mr-0 rtl:ml-2"></i>
                                <span id="optimize-prompt-btn-text" data-i18n-key="settingsOptimizePrompt">Optimize</span>
                                <svg id="optimize-prompt-spinner" class="spinner w-4 h-4 ml-2 rtl:ml-0 rtl:mr-2 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                            </button>
                        </div>
                    </div>
                    <div class="flex items-center pt-2 border-t border-slate-300 dark:border-slate-700">
                        <input id="pdf-ocr-checkbox" name="pdf_ocr" type="checkbox" class="h-4 w-4 rounded border-slate-400 dark:border-slate-600 bg-slate-200 dark:bg-slate-700 text-sky-600 focus:ring-sky-500">
                        <label for="pdf-ocr-checkbox" class="ml-2 rtl:ml-0 rtl:mr-2 block text-sm font-medium text-slate-600 dark:text-slate-400" data-i18n-key="settingsOcr">Use OCR for scanned PDF pages</label>
                    </div>
                    <div class="flex items-center pt-2 border-t border-slate-300 dark:border-slate-700">
                        <input id="save-settings-checkbox" type="checkbox" class="h-4 w-4 rounded border-slate-400 dark:border-slate-600 bg-slate-200 dark:bg-slate-700 text-sky-600 focus:ring-sky-500">
                        <label for="save-settings-checkbox" class="ml-2 rtl:ml-0 rtl:mr-2 block text-sm text-slate-600 dark:text-slate-400" data-i18n-key="settingsSave">Save all settings in this browser</label>
                    </div>
                </div>

                <div id="main-output-section">
                    <div class="relative">
                        <textarea id="output" data-i18n-placeholder-key="outputPlaceholder" placeholder="Translation will appear here..." readonly class="w-full min-h-[10rem] p-4 pr-32 rtl:pr-4 rtl:pl-32 bg-slate-200 dark:bg-slate-900 bg-input rounded-lg border-slate-300 dark:border-transparent resize-y"></textarea>
                        <div class="absolute top-3 right-3 rtl:right-auto rtl:left-3 flex items-center gap-2">
                            <button type="button" id="copy-btn" class="p-2 rounded-full bg-slate-300 dark:bg-slate-700 hover:bg-slate-400 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled data-i18n-title-key="copyBtnLabel" title="Copy output" aria-label="Copy output">
                                <svg id="copy-icon-default" class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" /></svg>
                                <svg id="copy-icon-success" class="w-5 h-5 text-green-600 dark:text-green-400 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>
                            </button>
                             <button type="button" id="export-text-btn" class="p-2 rounded-full bg-slate-300 dark:bg-slate-700 hover:bg-slate-400 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled data-i18n-title-key="exportTextBtnLabel" title="Export as TXT file" aria-label="Export as TXT file">
                               <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
                            </button>
                        </div>
                    </div>
                    
                    <div id="enhancements-toolbar" class="mt-4 p-4 bg-slate-200/50 dark:bg-slate-900/50 rounded-lg hidden opacity-0 -translate-y-2 space-y-4">
                        <div class="flex flex-wrap items-center justify-center gap-x-3 gap-y-2">
                            <span class="text-sm font-semibold text-slate-700 dark:text-slate-300" data-i18n-key="refineToolbarTitle">Refine:</span>
                            <button type="button" data-action="shorten" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600" data-i18n-key="refineShorten">Make Shorter</button>
                            <button type="button" data-action="expand" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600" data-i18n-key="refineExpand">Expand</button>
                            <button type="button" data-action="summarize" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600" data-i18n-key="refineSummarize">Summarize</button>
                        </div>
                        <div class="flex flex-wrap items-center justify-center gap-x-3 gap-y-2 border-t border-slate-300 dark:border-slate-700 pt-4">
                            <span class="text-sm font-semibold text-slate-700 dark:text-slate-300" data-i18n-key="styleToolbarTitle">Change Style:</span>
                            <button type="button" data-action="formal" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600">
                                <i class="fas fa-user-tie mr-1.5 rtl:mr-0 rtl:ml-1.5"></i><span data-i18n-key="styleFormal">Formal</span>
                            </button>
                            <button type="button" data-action="informal" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600">
                                <i class="fas fa-comments mr-1.5 rtl:mr-0 rtl:ml-1.5"></i><span data-i18n-key="styleInformal">Informal</span>
                            </button>
                            <button type="button" data-action="poetic" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600">
                                <i class="fas fa-feather-alt mr-1.5 rtl:mr-0 rtl:ml-1.5"></i><span data-i18n-key="stylePoetic">Poetic</span>
                            </button>
                            <button type="button" data-action="simplify" class="enhancement-btn px-3 py-1.5 text-sm font-medium rounded-md bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-slate-600">
                                <i class="fas fa-child mr-1.5 rtl:mr-0 rtl:ml-1.5"></i><span data-i18n-key="styleSimplify">Simplify</span>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="error-display" role="alert" class="mt-4 text-center text-red-600 dark:text-red-400 font-medium h-5"></div>
            </form>

        </div>
        
        <div id="log-viewer" class="w-full max-w-4xl mx-auto mt-4 bg-white dark:bg-slate-800 bg-card rounded-lg shadow-md dark:shadow-lg dark:shadow-black/30 overflow-hidden max-h-0">
            <button id="log-toggle" class="w-full p-3 text-left rtl:text-right font-semibold text-slate-700 dark:text-slate-200 bg-slate-100 dark:bg-slate-700/50 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors" data-i18n-key="logTitle">
                Live Activity Log
            </button>
            <div id="log-content" class="p-4 text-xs font-mono text-slate-600 dark:text-slate-400 max-h-64 overflow-y-auto scroll-container">
                <div id="log-output"></div>
            </div>
        </div>

        <footer class="max-w-4xl mx-auto py-8 px-4">
        </footer>
    </main>
    
    <div id="how-to-use-modal" class="hidden fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4 transition-opacity duration-300">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] flex flex-col">
            <header class="p-4 border-b dark:border-slate-700 flex justify-between items-center flex-shrink-0">
                <h2 id="how-to-use-title" class="text-xl font-bold" data-i18n-key="howToUseModalTitle">How to Use Fluentify</h2>
                <button id="how-to-use-close-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </header>
            <div id="how-to-use-content" class="p-6 overflow-y-auto text-sm sm:text-base leading-relaxed">
                <!-- Content will be injected by JS -->
            </div>
        </div>
    </div>

    <script>
        (() => {
            // --- START: CONFIGURATION & I18N ---
            const DEFAULT_WEB_MODEL = "gemini-2.5-pro";
            const DEFAULT_PROXY_URL = "https://sbt.fxsinahamidi.workers.dev";
            const MODELS = ['gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.5-flash-lite', 'gemini-2.0-flash', 'gemini-2.0-flash-lite'];
            const LANGUAGES = [ { value: "auto", text: "Auto-detect Language", i18nKey: "lang_auto" }, { value: "Afrikaans", text: "Afrikaans", i18nKey: "lang_af" }, { value: "Albanian", text: "Albanian", i18nKey: "lang_sq" }, { value: "Amharic", text: "Amharic", i18nKey: "lang_am" }, { value: "Arabic", text: "Arabic", i18nKey: "lang_ar" }, { value: "Armenian", text: "Armenian", i18nKey: "lang_hy" }, { value: "Assamese", text: "Assamese", i18nKey: "lang_as" }, { value: "Aymara", text: "Aymara", i18nKey: "lang_ay" }, { value: "Azerbaijani", text: "Azerbaijani", i18nKey: "lang_az" }, { value: "Bambara", text: "Bambara", i18nKey: "lang_bm" }, { value: "Basque", text: "Basque", i18nKey: "lang_eu" }, { value: "Belarusian", text: "Belarusian", i18nKey: "lang_be" }, { value: "Bengali", text: "Bengali", i18nKey: "lang_bn" }, { value: "Bhojpuri", text: "Bhojpuri", i18nKey: "lang_bho" }, { value: "Bosnian", text: "Bosnian", i18nKey: "lang_bs" }, { value: "Bulgarian", text: "Bulgarian", i18nKey: "lang_bg" }, { value: "Catalan", text: "Catalan", i18nKey: "lang_ca" }, { value: "Cebuano", text: "Cebuano", i18nKey: "lang_ceb" }, { value: "Chichewa", text: "Chichewa (Nyanja)", i18nKey: "lang_ny" }, { value: "Chinese (Simplified)", text: "Chinese (Simplified)", i18nKey: "lang_zh-CN" }, { value: "Chinese (Traditional)", text: "Chinese (Traditional)", i18nKey: "lang_zh-TW" }, { value: "Corsican", text: "Corsican", i18nKey: "lang_co" }, { value: "Croatian", text: "Croatian", i18nKey: "lang_hr" }, { value: "Czech", text: "Czech", i18nKey: "lang_cs" }, { value: "Danish", text: "Danish", i18nKey: "lang_da" }, { value: "Dhivehi", text: "Dhivehi", i18nKey: "lang_dv" }, { value: "Dogri", text: "Dogri", i18nKey: "lang_doi" }, { value: "Dutch", text: "Dutch", i18nKey: "lang_nl" }, { value: "English", text: "English", i18nKey: "lang_en" }, { value: "Esperanto", text: "Esperanto", i18nKey: "lang_eo" }, { value: "Estonian", text: "Estonian", i18nKey: "lang_et" }, { value: "Ewe", text: "Ewe", i18nKey: "lang_ee" }, { value: "Filipino", text: "Filipino (Tagalog)", i18nKey: "lang_tl" }, { value: "Finnish", text: "Finnish", i18nKey: "lang_fi" }, { value: "French", text: "French", i18nKey: "lang_fr" }, { value: "Frisian", text: "Frisian", i18nKey: "lang_fy" }, { value: "Galician", text: "Galician", i18nKey: "lang_gl" }, { value: "Georgian", text: "Georgian", i18nKey: "lang_ka" }, { value: "German", text: "German", i18nKey: "lang_de" }, { value: "Greek", text: "Greek", i18nKey: "lang_el" }, { value: "Guarani", text: "Guarani", i18nKey: "lang_gn" }, { value: "Gujarati", text: "Gujarati", i18nKey: "lang_gu" }, { value: "Haitian Creole", text: "Haitian Creole", i18nKey: "lang_ht" }, { value: "Hausa", text: "Hausa", i18nKey: "lang_ha" }, { value: "Hawaiian", text: "Hawaiian", i18nKey: "lang_haw" }, { value: "Hebrew", text: "Hebrew", i18nKey: "lang_iw" }, { value: "Hindi", text: "Hindi", i18nKey: "lang_hi" }, { value: "Hmong", text: "Hmong", i18nKey: "lang_hmn" }, { value: "Hungarian", text: "Hungarian", i18nKey: "lang_hu" }, { value: "Icelandic", text: "Icelandic", i18nKey: "lang_is" }, { value: "Igbo", text: "Igbo", i18nKey: "lang_ig" }, { value: "Ilocano", text: "Ilocano", i18nKey: "lang_ilo" }, { value: "Indonesian", text: "Indonesian", i18nKey: "lang_id" }, { value: "Irish", text: "Irish", i18nKey: "lang_ga" }, { value: "Italian", text: "Italian", i18nKey: "lang_it" }, { value: "Japanese", text: "Japanese", i18nKey: "lang_ja" }, { value: "Javanese", text: "Javanese", i18nKey: "lang_jw" }, { value: "Kannada", text: "Kannada", i18nKey: "lang_kn" }, { value: "Kazakh", text: "Kazakh", i18nKey: "lang_kk" }, { value: "Khmer", text: "Khmer", i18nKey: "lang_km" }, { value: "Kinyarwanda", text: "Kinyarwanda", i18nKey: "lang_rw" }, { value: "Konkani", text: "Konkani", i18nKey: "lang_gom" }, { value: "Korean", text: "Korean", i18nKey: "lang_ko" }, { value: "Krio", text: "Krio", i18nKey: "lang_kri" }, { value: "Kurdish (Kurmanji)", text: "Kurdish (Kurmanji)", i18nKey: "lang_ku" }, { value: "Kurdish (Sorani)", text: "Kurdish (Sorani)", i18nKey: "lang_ckb" }, { value: "Kyrgyz", text: "Kyrgyz", i18nKey: "lang_ky" }, { value: "Lao", text: "Lao", i18nKey: "lang_lo" }, { value: "Latin", text: "Latin", i18nKey: "lang_la" }, { value: "Latvian", text: "Latvian", i18nKey: "lang_lv" }, { value: "Lingala", text: "Lingala", i18nKey: "lang_ln" }, { value: "Lithuanian", text: "Lithuanian", i18nKey: "lang_lt" }, { value: "Luganda", text: "Luganda", i18nKey: "lang_lg" }, { value: "Luxembourgish", text: "Luxembourgish", i18nKey: "lang_lb" }, { value: "Macedonian", text: "Macedonian", i18nKey: "lang_mk" }, { value: "Maithili", text: "Maithili", i18nKey: "lang_mai" }, { value: "Malagasy", text: "Malagasy", i18nKey: "lang_mg" }, { value: "Malay", text: "Malay", i18nKey: "lang_ms" }, { value: "Malayalam", text: "Malayalam", i18nKey: "lang_ml" }, { value: "Maltese", text: "Maltese", i18nKey: "lang_mt" }, { value: "Maori", text: "Maori", i18nKey: "lang_mi" }, { value: "Marathi", text: "Marathi", i18nKey: "lang_mr" }, { value: "Meiteilon (Manipuri)", text: "Meiteilon (Manipuri)", i18nKey: "lang_mni-Mtei" }, { value: "Mizo", text: "Mizo", i18nKey: "lang_lus" }, { value: "Mongolian", text: "Mongolian", i18nKey: "lang_mn" }, { value: "Myanmar (Burmese)", text: "Myanmar (Burmese)", i18nKey: "lang_my" }, { value: "Nepali", text: "Nepali", i18nKey: "lang_ne" }, { value: "Norwegian", text: "Norwegian", i18nKey: "lang_no" }, { value: "Odia (Oriya)", text: "Odia (Oriya)", i18nKey: "lang_or" }, { value: "Oromo", text: "Oromo", i18nKey: "lang_om" }, { value: "Pashto", text: "Pashto", i18nKey: "lang_ps" }, { value: "Persian", text: "Persian (Farsi)", i18nKey: "lang_fa" }, { value: "Polish", text: "Polish", i18nKey: "lang_pl" }, { value: "Portuguese", text: "Portuguese", i18nKey: "lang_pt" }, { value: "Punjabi", text: "Punjabi", i18nKey: "lang_pa" }, { value: "Quechua", text: "Quechua", i18nKey: "lang_qu" }, { value: "Romanian", text: "Romanian", i18nKey: "lang_ro" }, { value: "Russian", text: "Russian", i18nKey: "lang_ru" }, { value: "Samoan", text: "Samoan", i18nKey: "lang_sm" }, { value: "Sanskrit", text: "Sanskrit", i18nKey: "lang_sa" }, { value: "Scots Gaelic", text: "Scots Gaelic", i18nKey: "lang_gd" }, { value: "Sepedi", text: "Sepedi", i18nKey: "lang_nso" }, { value: "Serbian", text: "Serbian", i18nKey: "lang_sr" }, { value: "Sesotho", text: "Sesotho", i18nKey: "lang_st" }, { value: "Shona", text: "Shona", i18nKey: "lang_sn" }, { value: "Sindhi", text: "Sindhi", i18nKey: "lang_sd" }, { value: "Sinhala", text: "Sinhala", i18nKey: "lang_si" }, { value: "Slovak", text: "Slovak", i18nKey: "lang_sk" }, { value: "Slovenian", text: "Slovenian", i18nKey: "lang_sl" }, { value: "Somali", text: "Somali", i18nKey: "lang_so" }, { value: "Spanish", text: "Spanish", i18nKey: "lang_es" }, { value: "Sundanese", text: "Sundanese", i18nKey: "lang_su" }, { value: "Swahili", text: "Swahili", i18nKey: "lang_sw" }, { value: "Swedish", text: "Swedish", i18nKey: "lang_sv" }, { value: "Tajik", text: "Tajik", i18nKey: "lang_tg" }, { value: "Tamil", text: "Tamil", i18nKey: "lang_ta" }, { value: "Tatar", text: "Tatar", i18nKey: "lang_tt" }, { value: "Telugu", text: "Telugu", i18nKey: "lang_te" }, { value: "Thai", text: "Thai", i18nKey: "lang_th" }, { value: "Tigrinya", text: "Tigrinya", i18nKey: "lang_ti" }, { value: "Tsonga", text: "Tsonga", i18nKey: "lang_ts" }, { value: "Turkish", text: "Turkish", i18nKey: "lang_tr" }, { value: "Turkmen", text: "Turkmen", i18nKey: "lang_tk" }, { value: "Twi", text: "Twi (Akan)", i18nKey: "lang_ak" }, { value: "Ukrainian", text: "Ukrainian", i18nKey: "lang_uk" }, { value: "Urdu", text: "Urdu", i18nKey: "lang_ur" }, { value: "Uyghur", text: "Uyghur", i18nKey: "lang_ug" }, { value: "Uzbek", text: "Uzbek", i18nKey: "lang_uz" }, { value: "Vietnamese", text: "Vietnamese", i18nKey: "lang_vi" }, { value: "Welsh", text: "Welsh", i18nKey: "lang_cy" }, { value: "Xhosa", text: "Xhosa", i18nKey: "lang_xh" }, { value: "Yiddish", text: "Yiddish", i18nKey: "lang_yi" }, { value: "Yoruba", text: "Yoruba", i18nKey: "lang_yo" }, { value: "Zulu", text: "Zulu", i18nKey: "lang_zu" }];
            const JOB_FIELDS = [ { value: "None", text: "None (General)", i18nKey: "job_None" }, { value: "Medical", text: "Medical / Healthcare", i18nKey: "job_Medical" }, { value: "Legal", text: "Legal / Law", i18nKey: "job_Legal" }, { value: "Engineering", text: "Engineering (General)", i18nKey: "job_Engineering" }, { value: "IT", text: "Information Technology / Software", i18nKey: "job_IT" }, { value: "Finance", text: "Finance / Banking", i18nKey: "job_Finance" }, { value: "Academic", text: "Academic / Research", i18nKey: "job_Academic" }, { value: "Marketing", text: "Marketing / Business", i18nKey: "job_Marketing" }, { value: "Cinema", text: "Cinema / TV Series", i18nKey: "job_Cinema" } ];
            const TONES = [ { value: "Default", text: "Default", i18nKey: "tone_Default" }, { value: "Formal", text: "Formal", i18nKey: "tone_Formal" }, { value: "Informal", text: "Informal", i18nKey: "tone_Informal" }, { value: "Poetic", text: "Poetic", i18nKey: "tone_Poetic" }, { value: "Technical", text: "Technical", i18nKey: "tone_Technical" }, { value: "Simplify", text: "Simple / Easy to read", i18nKey: "tone_Simplify" }, { value: "Custom", text: "Custom...", i18nKey: "tone_Custom" } ];
            const RTL_LANGUAGES = new Set(['Arabic', 'Hebrew', 'Persian', 'Urdu', 'Yiddish', 'Dhivehi', 'Sindhi', 'Pashto', 'Uyghur', 'Kurdish (Sorani)']);
            const TRANSLATIONS = {
                en: {
                    appTitle: "Fluentify", tabText: "Text", tabImage: "Image", tabPDF: "PDF", tabSubtitle: "Subtitle", swapBtnLabel: "Swap languages", textInputPlaceholder: "Enter text to translate...", youtubeSectionTitle: "Load from YouTube URL", youtubeUrlPlaceholder: "Enter YouTube Video URL...", youtubeLangPlaceholder: "lang", youtubeFetchBtn: "Fetch", youtubeNotice: `For much better subtitles than auto-generated ones for YouTube, try our new service: <a href="https://ytsrt.pages.dev" target="_blank" rel="noopener noreferrer" class="font-semibold underline text-sky-600 dark:text-sky-400 hover:text-sky-500 dark:hover:text-sky-300">YTSRT</a>.`, fileDragDrop: "Drag & drop a file", fileOr: "or", fileChooseBtn: "Choose File", fileHintImage: "PNG, JPG, WEBP, GIF (MAX. 20MB)", fileHintPDF: "PDF (MAX. 20MB)", fileHintSubtitle: "SRT, VTT, SSA, ASS (MAX. 20MB)", removeFileBtnLabel: "Remove file", pdfSelectPagesTitle: "Select Pages to Translate", pdfSelectAll: "Select All", pdfDeselectAll: "Deselect All", pdfPageCounter: "{count} pages selected", pdfCombinePages: "Combine selected pages before translation", pdfBatchWarning: "Translation may take up to {seconds} seconds to complete.", subtitleEditorTitle: "Subtitle Editor", subtitleLinesPerRequest: "Lines / Request", subtitleBreakLinesBtnLabel: "Break Long Lines", subtitleFindReplaceBtnLabel: "Find & Replace", subtitleExportBtnLabel: "Export as subtitle file", subtitleTranslateAll: "Translate All", subtitleSavedProgress: "Saved progress found for this file.", subtitleLoadProgress: "Load Progress", subtitleClearHistory: "Clear History", breakLinesPanelTitle: "Max chars / line:", breakLinesApply: "Apply Changes", findInputPlaceholder: "Find text...", replaceInputPlaceholder: "Replace with...", findCaseSensitive: "Case Sensitive", replaceAllBtn: "Replace All", subtitleTableHeaderNum: "#", subtitleTableHeaderTime: "Timestamp", subtitleTableHeaderOrig: "Original Text", subtitleTableHeaderTrans: "Translated Text", subtitleTableHeaderAction: "Action", subtitleTranslateRowBtn: "Translate", progressLabelTranslating: "Translating...", progressCancel: "Cancel", advSettingsBtn: "Advanced Settings", translateBtn: "Translate", settingsModel: "AI Model", settingsSpecialization: "Translation Specialization", settingsTone: "Translation Tone", settingsCustomToneLabel: "Custom Tone Instruction", settingsCustomTonePlaceholder: "e.g., 'Translate this in the style of a pirate.'", settingsCreativity: "Creativity (Temperature)", settingsRequestDelay: "Request Delay (seconds)", settingsApiKey: "Google AI API Key(s)", settingsApiKeyPlaceholder: "Enter your API Keys, one per line.", settingsApiKeyHint: "Enter multiple keys to distribute load or as backups.", settingsUseProxy: "Use Proxy", settingsCustomProxyLabel: "Custom Proxy URL (Optional)", settingsCustomProxyHint: `Deploy your own proxy using <a href="https://github.com/yebekhe/middleman" target="_blank" rel="noopener noreferrer" class="underline hover:text-sky-500">Middleman</a>.`, settingsUseCustomPrompt: "Use Custom Prompt", settingsCustomPromptPlaceholder: "Enter your custom prompt. Use {text}, {source_lang}, and {target_lang} as placeholders.", settingsOptimizePrompt: "Optimize", settingsOcr: "Use OCR for scanned PDF pages", settingsSave: "Save all settings in this browser", outputPlaceholder: "Translation will appear here...", copyBtnLabel: "Copy output", exportTextBtnLabel: "Export as TXT file", refineToolbarTitle: "Refine:", refineShorten: "Make Shorter", refineExpand: "Expand", refineSummarize: "Summarize", styleToolbarTitle: "Change Style:", styleFormal: "Formal", styleInformal: "Informal", stylePoetic: "Poetic", styleSimplify: "Simplify", logTitle: "Live Activity Log", footerText: `Created with <i class="fas fa-heart text-red-500 mx-1"></i> `, pageTitle: "Fluentify - Modern AI Translator", howToUseBtnLabel: "How to use", howToUseModalTitle: "How to Use Fluentify",
                    lang_auto: "Auto-detect Language", lang_af: "Afrikaans", lang_sq: "Albanian", lang_am: "Amharic", lang_ar: "Arabic", lang_hy: "Armenian", lang_as: "Assamese", lang_ay: "Aymara", lang_az: "Azerbaijani", lang_bm: "Bambara", lang_eu: "Basque", lang_be: "Belarusian", lang_bn: "Bengali", lang_bho: "Bhojpuri", lang_bs: "Bosnian", lang_bg: "Bulgarian", lang_ca: "Catalan", lang_ceb: "Cebuano", lang_ny: "Chichewa (Nyanja)", "lang_zh-CN": "Chinese (Simplified)", "lang_zh-TW": "Chinese (Traditional)", lang_co: "Corsican", lang_hr: "Croatian", lang_cs: "Czech", lang_da: "Danish", lang_dv: "Dhivehi", lang_doi: "Dogri", lang_nl: "Dutch", lang_en: "English", lang_eo: "Esperanto", lang_et: "Estonian", lang_ee: "Ewe", lang_tl: "Filipino (Tagalog)", lang_fi: "Finnish", lang_fr: "French", lang_fy: "Frisian", lang_gl: "Galician", lang_ka: "Georgian", lang_de: "German", lang_el: "Greek", lang_gn: "Guarani", lang_gu: "Gujarati", lang_ht: "Haitian Creole", lang_ha: "Hausa", lang_haw: "Hawaiian", lang_iw: "Hebrew", lang_hi: "Hindi", lang_hmn: "Hmong", lang_hu: "Hungarian", lang_is: "Icelandic", lang_ig: "Igbo", lang_ilo: "Ilocano", lang_id: "Indonesian", lang_ga: "Irish", lang_it: "Italian", lang_ja: "Japanese", lang_jw: "Javanese", lang_kn: "Kannada", lang_kk: "Kazakh", lang_km: "Khmer", lang_rw: "Kinyarwanda", lang_gom: "Konkani", lang_ko: "Korean", lang_kri: "Krio", lang_ku: "Kurdish (Kurmanji)", lang_ckb: "Kurdish (Sorani)", lang_ky: "Kyrgyz", lang_lo: "Lao", lang_la: "Latin", lang_lv: "Latvian", lang_ln: "Lingala", lang_lt: "Lithuanian", lang_lg: "Luganda", lang_lb: "Luxembourgish", lang_mk: "Macedonian", lang_mai: "Maithili", lang_mg: "Malagasy", lang_ms: "Malay", lang_ml: "Malayalam", lang_mt: "Maltese", lang_mi: "Maori", lang_mr: "Marathi", "lang_mni-Mtei": "Meiteilon (Manipuri)", lang_lus: "Mizo", lang_mn: "Mongolian", lang_my: "Myanmar (Burmese)", lang_ne: "Nepali", lang_no: "Norwegian", lang_or: "Odia (Oriya)", lang_om: "Oromo", lang_ps: "Pashto", lang_fa: "Persian (Farsi)", lang_pl: "Polish", lang_pt: "Portuguese", lang_pa: "Punjabi", lang_qu: "Quechua", lang_ro: "Romanian", lang_ru: "Russian", lang_sm: "Samoan", lang_sa: "Sanskrit", lang_gd: "Scots Gaelic", lang_nso: "Sepedi", lang_sr: "Serbian", lang_st: "Sesotho", lang_sn: "Shona", lang_sd: "Sindhi", lang_si: "Sinhala", lang_sk: "Slovak", lang_sl: "Slovenian", lang_so: "Somali", lang_es: "Spanish", lang_su: "Sundanese", lang_sw: "Swahili", lang_sv: "Swedish", lang_tg: "Tajik", lang_ta: "Tamil", lang_tt: "Tatar", lang_te: "Telugu", lang_th: "Thai", lang_ti: "Tigrinya", lang_ts: "Tsonga", lang_tr: "Turkish", lang_tk: "Turkmen", lang_ak: "Twi (Akan)", lang_uk: "Ukrainian", lang_ur: "Urdu", lang_ug: "Uyghur", lang_uz: "Uzbek", lang_vi: "Vietnamese", lang_cy: "Welsh", lang_xh: "Xhosa", lang_yi: "Yiddish", lang_yo: "Yoruba", lang_zu: "Zulu",
                    job_None: "None (General)", job_Medical: "Medical / Healthcare", job_Legal: "Legal / Law", job_Engineering: "Engineering (General)", job_IT: "Information Technology / Software", job_Finance: "Finance / Banking", job_Academic: "Academic / Research", job_Marketing: "Marketing / Business", job_Cinema: "Cinema / TV Series",
                    tone_Default: "Default", tone_Formal: "Formal", tone_Informal: "Informal", tone_Poetic: "Poetic", tone_Technical: "Technical", tone_Simplify: "Simple / Easy to read", tone_Custom: "Custom..."
                },
                fa: {
                    appTitle: "فلوئنتیفای", tabText: "متن", tabImage: "تصویر", tabPDF: "PDF", tabSubtitle: "زیرنویس", swapBtnLabel: "جابجایی زبان‌ها", textInputPlaceholder: "متن را برای ترجمه وارد کنید...", youtubeSectionTitle: "بارگذاری از آدرس یوتیوب", youtubeUrlPlaceholder: "آدرس ویدیوی یوتیوب را وارد کنید...", youtubeLangPlaceholder: "زبان", youtubeFetchBtn: "دریافت", youtubeNotice: `برای دریافت زیرنویس‌های بسیار بهتر از زیرنویس‌های تولید خودکار یوتیوب، سرویس جدید ما را امتحان کنید: <a href="https://ytsrt.pages.dev" target="_blank" rel="noopener noreferrer" class="font-semibold underline text-sky-600 dark:text-sky-400 hover:text-sky-500 dark:hover:text-sky-300">YTSRT</a>.`, fileDragDrop: "فایل را بکشید و رها کنید", fileOr: "یا", fileChooseBtn: "انتخاب فایل", fileHintImage: "PNG, JPG, WEBP, GIF (حداکثر ۲۰ مگابایت)", fileHintPDF: "PDF (حداکثر ۲۰ مگابایت)", fileHintSubtitle: "SRT, VTT, SSA, ASS (حداکثر ۲۰ مگابایت)", removeFileBtnLabel: "حذف فایل", pdfSelectPagesTitle: "انتخاب صفحات برای ترجمه", pdfSelectAll: "انتخاب همه", pdfDeselectAll: "لغو انتخاب همه", pdfPageCounter: "{count} صفحه انتخاب شد", pdfCombinePages: "ادغام صفحات انتخاب شده قبل از ترجمه", pdfBatchWarning: "ترجمه ممکن است تا {seconds} ثانیه طول بکشد.", subtitleEditorTitle: "ویرایشگر زیرنویس", subtitleLinesPerRequest: "خط / درخواست", subtitleBreakLinesBtnLabel: "شکستن خطوط طولانی", subtitleFindReplaceBtnLabel: "جستجو و جایگزینی", subtitleExportBtnLabel: "خروجی به عنوان فایل زیرنویس", subtitleTranslateAll: "ترجمه همه", subtitleSavedProgress: "پیشرفت ذخیره شده برای این فایل پیدا شد.", subtitleLoadProgress: "بارگذاری پیشرفت", subtitleClearHistory: "پاک کردن تاریخچه", breakLinesPanelTitle: "حداکثر کاراکتر / خط:", breakLinesApply: "اعمال تغییرات", findInputPlaceholder: "جستجوی متن...", replaceInputPlaceholder: "جایگزینی با...", findCaseSensitive: "حساس به حروف بزرگ و کوچک", replaceAllBtn: "جایگزینی همه", subtitleTableHeaderNum: "#", subtitleTableHeaderTime: "برچسب زمانی", subtitleTableHeaderOrig: "متن اصلی", subtitleTableHeaderTrans: "متن ترجمه شده", subtitleTableHeaderAction: "عملیات", subtitleTranslateRowBtn: "ترجمه", progressLabelTranslating: "در حال ترجمه...", progressCancel: "لغو", advSettingsBtn: "تنظیمات پیشرفته", translateBtn: "ترجمه", settingsModel: "مدل هوش مصنوعی", settingsSpecialization: "تخصص ترجمه", settingsTone: "لحن ترجمه", settingsCustomToneLabel: "دستورالعمل لحن سفارشی", settingsCustomTonePlaceholder: "مثال: 'این متن را به سبک دزدان دریایی ترجمه کن.'", settingsCreativity: "خلاقیت (Temperature)", settingsRequestDelay: "تأخیر درخواست (ثانیه)", settingsApiKey: "کلید(های) API گوگل", settingsApiKeyPlaceholder: "کلیدهای API خود را وارد کنید، هر کدام در یک خط.", settingsApiKeyHint: "چندین کلید برای توزیع بار یا به عنوان پشتیبان وارد کنید.", settingsUseProxy: "استفاده از پروکسی", settingsCustomProxyLabel: "آدرس پروکسی سفارشی (اختیاری)", settingsCustomProxyHint: `پروکسی خود را با استفاده از <a href="https://github.com/yebekhe/middleman" target="_blank" rel="noopener noreferrer" class="underline hover:text-sky-500">Middleman</a> مستقر کنید.`, settingsUseCustomPrompt: "استفاده از پرامپت سفارشی", settingsCustomPromptPlaceholder: "پرامپت سفارشی خود را وارد کنید. از {text}، {source_lang} و {target_lang} به عنوان متغیر استفاده کنید.", settingsOptimizePrompt: "بهینه‌سازی", settingsOcr: "استفاده از OCR برای صفحات PDF اسکن شده", settingsSave: "ذخیره تمام تنظیمات در این مرورگر", outputPlaceholder: "ترجمه در اینجا نمایش داده خواهد شد...", copyBtnLabel: "کپی خروجی", exportTextBtnLabel: "خروجی به عنوان فایل TXT", refineToolbarTitle: "اصلاح:", refineShorten: "کوتاه‌تر کردن", refineExpand: "گسترش دادن", refineSummarize: "خلاصه کردن", styleToolbarTitle: "تغییر سبک:", styleFormal: "رسمی", styleInformal: "غیررسمی", stylePoetic: "شاعرانه", styleSimplify: "ساده‌سازی", logTitle: "گزارش فعالیت زنده", footerText: ` شده  <i class="fas fa-heart text-red-500 mx-1"></i> `, pageTitle: "Fluentify - مترجم مدرن هوش مصنوعی", howToUseBtnLabel: "راهنمای استفاده", howToUseModalTitle: "راهنمای استفاده از Fluentify",
                    lang_auto: "تشخیص خودکار زبان", lang_af: "آفریکانس", lang_sq: "آلبانیایی", lang_am: "امهری", lang_ar: "عربی", lang_hy: "ارمنی", lang_as: "آسامی", lang_ay: "آیمارا", lang_az: "آذربایجانی", lang_bm: "بامبارا", lang_eu: "باسکی", lang_be: "بلاروسی", lang_bn: "بنگالی", lang_bho: "بوجپوری", lang_bs: "بوسنیایی", lang_bg: "بلغاری", lang_ca: "کاتالان", lang_ceb: "سبوانو", lang_ny: "چیچوا", "lang_zh-CN": "چینی (ساده شده)", "lang_zh-TW": "چینی (سنتی)", lang_co: "کرسی", lang_hr: "کرواتی", lang_cs: "چکی", lang_da: "دانمارکی", lang_dv: "دیوهی", lang_doi: "دوگری", lang_nl: "هلندی", lang_en: "انگلیسی", lang_eo: "اسپرانتو", lang_et: "استونیایی", lang_ee: "اوه", lang_tl: "فیلیپینی (تاگالوگ)", lang_fi: "فنلاندی", lang_fr: "فرانسوی", lang_fy: "فریزی", lang_gl: "گالیسی", lang_ka: "گرجی", lang_de: "آلمانی", lang_el: "یونانی", lang_gn: "گوارانی", lang_gu: "گجراتی", lang_ht: "کریول هائیتی", lang_ha: "هوسا", lang_haw: "هاوایی", lang_iw: "عبری", lang_hi: "هندی", lang_hmn: "همونگ", lang_hu: "مجاری", lang_is: "ایسلندی", lang_ig: "ایگبو", lang_ilo: "ایلوکانو", lang_id: "اندونزیایی", lang_ga: "ایرلندی", lang_it: "ایتالیایی", lang_ja: "ژاپنی", lang_jw: "جاوه‌ای", lang_kn: "کانارا", lang_kk: "قزاقی", lang_km: "خمر", lang_rw: "کینیارواندا", lang_gom: "کونکانی", lang_ko: "کره‌ای", lang_kri: "کریو", lang_ku: "کردی (کرمانجی)", lang_ckb: "کردی (سورانی)", lang_ky: "قرقیزی", lang_lo: "لائوسی", lang_la: "لاتین", lang_lv: "لتونیایی", lang_ln: "لینگالا", lang_lt: "لیتوانیایی", lang_lg: "لوگاندا", lang_lb: "لوکزامبورگی", lang_mk: "مقدونی", lang_mai: "مایتهیلی", lang_mg: "مالاگاسی", lang_ms: "مالایی", lang_ml: "مالایالام", lang_mt: "مالتی", lang_mi: "مائوری", lang_mr: "مراتی", "lang_mni-Mtei": "می‌تیلون (مانیپوری)", lang_lus: "میزو", lang_mn: "مغولی", lang_my: "میانماری (برمه‌ای)", lang_ne: "نپالی", lang_no: "نروژی", lang_or: "اوریا", lang_om: "اورومو", lang_ps: "پشتو", lang_fa: "فارسی", lang_pl: "لهستانی", lang_pt: "پرتغالی", lang_pa: "پنجابی", lang_qu: "کچوآ", lang_ro: "رومانیایی", lang_ru: "روسی", lang_sm: "ساموآیی", lang_sa: "سانسکریت", lang_gd: "گیلی اسکاتلندی", lang_nso: "سپدی", lang_sr: "صربی", lang_st: "سسوتو", lang_sn: "شونا", lang_sd: "سندی", lang_si: "سینهالی", lang_sk: "اسلواکی", lang_sl: "اسلوونیایی", lang_so: "سومالیایی", lang_es: "اسپانیایی", lang_su: "سوندانی", lang_sw: "سواحیلی", lang_sv: "سوئدی", lang_tg: "تاجیکی", lang_ta: "تامیلی", lang_tt: "تاتاری", lang_te: "تلوگو", lang_th: "تایلندی", lang_ti: "تیگرینیا", lang_ts: "تسونگا", lang_tr: "ترکی", lang_tk: "ترکمنی", lang_ak: "توی (آکان)", lang_uk: "اوکراینی", lang_ur: "اردو", lang_ug: "اویغوری", lang_uz: "ازبکی", lang_vi: "ویتنامی", lang_cy: "ولزی", lang_xh: "خوسا", lang_yi: "ییدیش", lang_yo: "یوروبا", lang_zu: "زولو",
                    job_None: "هیچکدام (عمومی)", job_Medical: "پزشکی / بهداشت", job_Legal: "حقوقی / قانون", job_Engineering: "مهندسی (عمومی)", job_IT: "فناوری اطلاعات / نرم‌افزار", job_Finance: "مالی / بانکداری", job_Academic: "دانشگاهی / تحقیقاتی", job_Marketing: "بازاریابی / کسب و کار", job_Cinema: "سینما / سریال تلویزیونی",
                    tone_Default: "پیش‌فرض", tone_Formal: "رسمی", tone_Informal: "غیررسمی", tone_Poetic: "شاعرانه", tone_Technical: "فنی", tone_Simplify: "ساده / روان", tone_Custom: "سفارشی..."
                },
                ru: {
                    appTitle: "Fluentify", tabText: "Текст", tabImage: "Изображение", tabPDF: "PDF", tabSubtitle: "Субтитры", swapBtnLabel: "Поменять языки", textInputPlaceholder: "Введите текст для перевода...", youtubeSectionTitle: "Загрузить с YouTube URL", youtubeUrlPlaceholder: "Введите URL видео YouTube...", youtubeLangPlaceholder: "язык", youtubeFetchBtn: "Получить", youtubeNotice: `Для получения субтитров лучшего качества, чем автоматически сгенерированные на YouTube, попробуйте наш новый сервис: <a href="https://ytsrt.pages.dev" target="_blank" rel="noopener noreferrer" class="font-semibold underline text-sky-600 dark:text-sky-400 hover:text-sky-500 dark:hover:text-sky-300">YTSRT</a>.`, fileDragDrop: "Перетащите файл", fileOr: "или", fileChooseBtn: "Выберите файл", fileHintImage: "PNG, JPG, WEBP, GIF (МАКС. 20МБ)", fileHintPDF: "PDF (МАКС. 20МБ)", fileHintSubtitle: "SRT, VTT, SSA, ASS (МАКС. 20МБ)", removeFileBtnLabel: "Удалить файл", pdfSelectPagesTitle: "Выберите страницы для перевода", pdfSelectAll: "Выбрать все", pdfDeselectAll: "Снять выбор", pdfPageCounter: "Выбрано страниц: {count}", pdfCombinePages: "Объединить выбранные страницы перед переводом", pdfBatchWarning: "Перевод может занять до {seconds} секунд.", subtitleEditorTitle: "Редактор субтитров", subtitleLinesPerRequest: "Строк / запрос", subtitleBreakLinesBtnLabel: "Разбить длинные строки", subtitleFindReplaceBtnLabel: "Найти и заменить", subtitleExportBtnLabel: "Экспортировать как файл субтитров", subtitleTranslateAll: "Перевести все", subtitleSavedProgress: "Найден сохраненный прогресс для этого файла.", subtitleLoadProgress: "Загрузить прогресс", subtitleClearHistory: "Очистить историю", breakLinesPanelTitle: "Макс. символов / строка:", breakLinesApply: "Применить изменения", findInputPlaceholder: "Найти текст...", replaceInputPlaceholder: "Заменить на...", findCaseSensitive: "Учитывать регистр", replaceAllBtn: "Заменить все", subtitleTableHeaderNum: "#", subtitleTableHeaderTime: "Временная метка", subtitleTableHeaderOrig: "Оригинальный текст", subtitleTableHeaderTrans: "Переведенный текст", subtitleTableHeaderAction: "Действие", subtitleTranslateRowBtn: "Перевести", progressLabelTranslating: "Перевод...", progressCancel: "Отмена", advSettingsBtn: "Расширенные настройки", translateBtn: "Перевести", settingsModel: "Модель ИИ", settingsSpecialization: "Специализация перевода", settingsTone: "Тон перевода", settingsCustomToneLabel: "Инструкция для пользовательского тона", settingsCustomTonePlaceholder: "напр., 'Переведи это в стиле пирата.'", settingsCreativity: "Креативность (Temperature)", settingsRequestDelay: "Задержка запроса (секунды)", settingsApiKey: "Ключ(и) API Google AI", settingsApiKeyPlaceholder: "Введите ваши ключи API, по одному на строку.", settingsApiKeyHint: "Введите несколько ключей для распределения нагрузки или как резервные.", settingsUseProxy: "Использовать прокси", settingsCustomProxyLabel: "Пользовательский URL прокси (необязательно)", settingsCustomProxyHint: `Разверните свой собственный прокси с помощью <a href="https://github.com/yebekhe/middleman" target="_blank" rel="noopener noreferrer" class="underline hover:text-sky-500">Middleman</a>.`, settingsUseCustomPrompt: "Использовать свой промпт", settingsCustomPromptPlaceholder: "Введите свой промпт. Используйте {text}, {source_lang} и {target_lang} как переменные.", settingsOptimizePrompt: "Оптимизировать", settingsOcr: "Использовать OCR для сканированных PDF", settingsSave: "Сохранить все настройки в этом браузере", outputPlaceholder: "Перевод появится здесь...", copyBtnLabel: "Копировать результат", exportTextBtnLabel: "Экспортировать в TXT", refineToolbarTitle: "Улучшить:", refineShorten: "Сделать короче", refineExpand: "Расширить", refineSummarize: "Суммировать", styleToolbarTitle: "Изменить стиль:", styleFormal: "Формальный", styleInformal: "Неформальный", stylePoetic: "Поэтический", styleSimplify: "Упростить", logTitle: "Журнал активности", footerText: `Создано с <i class="fas fa-heart text-red-500 mx-1"></i> `, pageTitle: "Fluentify - Современный ИИ-переводчик", howToUseBtnLabel: "Как использовать", howToUseModalTitle: "Как использовать Fluentify",
                    lang_auto: "Автоопределение языка", lang_af: "Африкаанс", lang_sq: "Албанский", lang_am: "Амхарский", lang_ar: "Арабский", lang_hy: "Армянский", lang_as: "Ассамский", lang_ay: "Аймара", lang_az: "Азербайджанский", lang_bm: "Бамбара", lang_eu: "Баскский", lang_be: "Белорусский", lang_bn: "Бенгальский", lang_bho: "Бходжпури", lang_bs: "Боснийский", lang_bg: "Болгарский", lang_ca: "Каталанский", lang_ceb: "Себуанский", lang_ny: "Чичева", "lang_zh-CN": "Китайский (упрощенный)", "lang_zh-TW": "Китайский (традиционный)", lang_co: "Корсиканский", lang_hr: "Хорватский", lang_cs: "Чешский", lang_da: "Датский", lang_dv: "Дивехи", lang_doi: "Догри", lang_nl: "Голландский", lang_en: "Английский", lang_eo: "Эсперанто", lang_et: "Эстонский", lang_ee: "Эве", lang_tl: "Филиппинский (тагальский)", lang_fi: "Финский", lang_fr: "Французский", lang_fy: "Фризский", lang_gl: "Галисийский", lang_ka: "Грузинский", lang_de: "Немецкий", lang_el: "Греческий", lang_gn: "Гуарани", lang_gu: "Гуджарати", lang_ht: "Гаитянский креольский", lang_ha: "Хауса", lang_haw: "Гавайский", lang_iw: "Иврит", lang_hi: "Хинди", lang_hmn: "Хмонг", lang_hu: "Венгерский", lang_is: "Исландский", lang_ig: "Игбо", lang_ilo: "Илоканский", lang_id: "Индонезийский", lang_ga: "Ирландский", lang_it: "Итальянский", lang_ja: "Японский", lang_jw: "Яванский", lang_kn: "Каннада", lang_kk: "Казахский", lang_km: "Кхмерский", lang_rw: "Киньяруанда", lang_gom: "Конкани", lang_ko: "Корейский", lang_kri: "Крио", lang_ku: "Курдский (курманджи)", lang_ckb: "Курдский (сорани)", lang_ky: "Киргизский", lang_lo: "Лаосский", lang_la: "Латинский", lang_lv: "Латышский", lang_ln: "Лингала", lang_lt: "Литовский", lang_lg: "Луганда", lang_lb: "Люксембургский", lang_mk: "Македонский", lang_mai: "Майтхили", lang_mg: "Малагасийский", lang_ms: "Малайский", lang_ml: "Малаялам", lang_mt: "Мальтийский", lang_mi: "Маори", lang_mr: "Маратхи", "lang_mni-Mtei": "Меитеилон (манипури)", lang_lus: "Мизо", lang_mn: "Монгольский", lang_my: "Бирманский", lang_ne: "Непальский", lang_no: "Норвежский", lang_or: "Ория", lang_om: "Оромо", lang_ps: "Пушту", lang_fa: "Персидский (фарси)", lang_pl: "Польский", lang_pt: "Португальский", lang_pa: "Панджаби", lang_qu: "Кечуа", lang_ro: "Румынский", lang_ru: "Русский", lang_sm: "Самоанский", lang_sa: "Санскрит", lang_gd: "Шотландский гэльский", lang_nso: "Сепеди", lang_sr: "Сербский", lang_st: "Сесото", lang_sn: "Шона", lang_sd: "Синдхи", lang_si: "Сингальский", lang_sk: "Словацкий", lang_sl: "Словенский", lang_so: "Сомалийский", lang_es: "Испанский", lang_su: "Сунданский", lang_sw: "Суахили", lang_sv: "Шведский", lang_tg: "Таджикский", lang_ta: "Тамильский", lang_tt: "Татарский", lang_te: "Телугу", lang_th: "Тайский", lang_ti: "Тигринья", lang_ts: "Тсонга", lang_tr: "Турецкий", lang_tk: "Туркменский", lang_ak: "Тви (акан)", lang_uk: "Украинский", lang_ur: "Урду", lang_ug: "Уйгурский", lang_uz: "Узбекский", lang_vi: "Вьетнамский", lang_cy: "Валлийский", lang_xh: "Коса", lang_yi: "Идиш", lang_yo: "Йоруба", lang_zu: "Зулу",
                    job_None: "Нет (общий)", job_Medical: "Медицина / Здравоохранение", job_Legal: "Юриспруденция / Право", job_Engineering: "Инженерия (общая)", job_IT: "ИТ / Программное обеспечение", job_Finance: "Финансы / Банковское дело", job_Academic: "Наука / Исследования", job_Marketing: "Маркетинг / Бизнес", job_Cinema: "Кино / Сериалы",
                    tone_Default: "По умолчанию", tone_Formal: "Формальный", tone_Informal: "Неформальный", tone_Poetic: "Поэтический", tone_Technical: "Технический", tone_Simplify: "Простой / Легко читаемый", tone_Custom: "Пользовательский..."
                }
            };
            const HOW_TO_USE_CONTENT = {
                en: `<div class="space-y-6 text-slate-700 dark:text-slate-300">
                        <div>
                            <h3 class="text-lg font-bold mb-2 text-slate-800 dark:text-slate-100">1. Initial Setup (API Key)</h3>
                            <p class="mb-2">Before you can translate, you need a Google AI API Key.</p>
                            <ol class="list-decimal list-inside space-y-2 pl-4">
                                <li>Go to <a href="https://aistudio.google.com/" target="_blank" rel="noopener noreferrer" class="text-sky-500 underline">Google AI Studio</a> and sign in.</li>
                                <li>Click <strong>"Get API key"</strong>, then <strong>"Create API key in new project"</strong>.</li>
                                <li>Copy the generated key.</li>
                                <li>In Fluentify, click <strong>"Advanced Settings"</strong>.</li>
                                <li>Paste your key into the <strong>"Google AI API Key(s)"</strong> field.</li>
                                <li>(Recommended) Check the <strong>"Save all settings in this browser"</strong> box to store your key securely for future use.</li>
                            </ol>
                        </div>
                        <div>
                            <h3 class="text-lg font-bold mb-2 text-slate-800 dark:text-slate-100">2. Translating Content</h3>
                            <p class="mb-3">Select your desired input type from the top menu: <strong>Text, Image, PDF, or Subtitle</strong>.</p>
                            <div class="space-y-4 pl-4 border-l-2 dark:border-slate-600">
                                <div>
                                    <h4 class="font-semibold">📝 Text Translation</h4>
                                    <p>Select the source and target languages, enter your text, and click <strong>Translate</strong>. Use the <strong>Refine</strong> and <strong>Change Style</strong> buttons to enhance the output.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">🖼️ Image Translation</h4>
                                    <p>Select the <strong>Image</strong> tab, choose your target language, and drop an image file. The app will perform OCR to extract the text and then translate it.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">📄 PDF Translation</h4>
                                    <p>Upload a PDF. Click on the pages you want to translate. For scanned PDFs, enable <strong>"Use OCR for scanned PDF pages"</strong> in Advanced Settings. Click <strong>Translate</strong>.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">🎬 Subtitle Translation</h4>
                                    <p class="mb-2">Either upload a subtitle file (SRT, VTT, etc.) or paste a YouTube URL and click <strong>Fetch</strong> to load subtitles into the editor.</p>
                                    <ul class="list-disc list-inside space-y-1">
                                        <li><strong>Translate All:</strong> Click to translate all lines in batches.</li>
                                        <li><strong>Edit:</strong> Click directly on any translated text to edit it manually.</li>
                                        <li><strong>Tools:</strong> Use the Find & Replace and Break Long Lines tools for advanced editing.</li>
                                        <li><strong>Export:</strong> Click the export button in the editor's header to download your translated file.</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>`,
                fa: `<div class="space-y-6 text-slate-700 dark:text-slate-300 text-right">
                        <div>
                            <h3 class="text-lg font-bold mb-2 text-slate-800 dark:text-slate-100">۱. راه‌اندازی اولیه (کلید API)</h3>
                            <p class="mb-2">قبل از شروع ترجمه، به یک کلید API از Google AI نیاز دارید.</p>
                            <ol class="list-decimal list-inside space-y-2 pr-4">
                                <li>به <a href="https://aistudio.google.com/" target="_blank" rel="noopener noreferrer" class="text-sky-500 underline">Google AI Studio</a> بروید و وارد شوید.</li>
                                <li>روی <strong>"Get API key"</strong> و سپس <strong>"Create API key in new project"</strong> کلیک کنید.</li>
                                <li>کلید تولید شده را کپی کنید.</li>
                                <li>در Fluentify، روی <strong>"تنظیمات پیشرفته"</strong> کلیک کنید.</li>
                                <li>کلید خود را در فیلد <strong>"کلید(های) API گوگل"</strong> الصاق کنید.</li>
                                <li>(توصیه‌شده) تیک گزینه <strong>"ذخیره تمام تنظیمات در این مرورگر"</strong> را بزنید تا کلید شما برای استفاده‌های بعدی ذخیره شود.</li>
                            </ol>
                        </div>
                        <div>
                            <h3 class="text-lg font-bold mb-2 text-slate-800 dark:text-slate-100">۲. ترجمه محتوا</h3>
                            <p class="mb-3">نوع ورودی مورد نظر خود را از منوی بالا انتخاب کنید: <strong>متن، تصویر، PDF یا زیرنویس</strong>.</p>
                            <div class="space-y-4 pr-4 border-r-2 dark:border-slate-600">
                                <div>
                                    <h4 class="font-semibold">📝 ترجمه متن</h4>
                                    <p>زبان مبدأ و مقصد را انتخاب کنید، متن خود را وارد کرده و روی <strong>ترجمه</strong> کلیک کنید. از دکمه‌های <strong>اصلاح</strong> و <strong>تغییر سبک</strong> برای بهبود خروجی استفاده کنید.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">🖼️ ترجمه تصویر</h4>
                                    <p>تب <strong>تصویر</strong> را انتخاب کنید، زبان مقصد خود را برگزینید و یک فایل تصویر را رها کنید. برنامه متن را با OCR استخراج کرده و سپس آن را ترجمه می‌کند.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">📄 ترجمه PDF</h4>
                                    <p>یک فایل PDF آپلود کنید. روی صفحاتی که می‌خواهید ترجمه شوند کلیک کنید. برای PDFهای اسکن شده، گزینه <strong>"استفاده از OCR"</strong> را در تنظیمات پیشرفته فعال کنید. روی <strong>ترجمه</strong> کلیک کنید.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">🎬 ترجمه زیرنویس</h4>
                                    <p class="mb-2">می‌توانید یک فایل زیرنویس (SRT, VTT, و غیره) آپلود کنید یا یک آدرس یوتیوب را وارد کرده و روی <strong>دریافت</strong> کلیک کنید تا زیرنویس‌ها در ویرایشگر بارگذاری شوند.</p>
                                    <ul class="list-disc list-inside space-y-1">
                                        <li><strong>ترجمه همه:</strong> برای ترجمه تمام خطوط به صورت دسته‌ای کلیک کنید.</li>
                                        <li><strong>ویرایش:</strong> برای ویرایش دستی، مستقیماً روی متن ترجمه شده کلیک کنید.</li>
                                        <li><strong>ابزارها:</strong> از ابزارهای جستجو و جایگزینی و شکستن خطوط طولانی برای ویرایش پیشرفته استفاده کنید.</li>
                                        <li><strong>خروجی:</strong> برای دانلود فایل ترجمه شده، روی دکمه خروجی در هدر ویرایشگر کلیک کنید.</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>`,
                ru: `<div class="space-y-6 text-slate-700 dark:text-slate-300">
                        <div>
                            <h3 class="text-lg font-bold mb-2 text-slate-800 dark:text-slate-100">1. Начальная настройка (API-ключ)</h3>
                            <p class="mb-2">Перед началом работы вам понадобится API-ключ от Google AI.</p>
                            <ol class="list-decimal list-inside space-y-2 pl-4">
                                <li>Перейдите в <a href="https://aistudio.google.com/" target="_blank" rel="noopener noreferrer" class="text-sky-500 underline">Google AI Studio</a> и войдите в систему.</li>
                                <li>Нажмите <strong>"Get API key"</strong>, затем <strong>"Create API key in new project"</strong>.</li>
                                <li>Скопируйте сгенерированный ключ.</li>
                                <li>В Fluentify нажмите <strong>"Расширенные настройки"</strong>.</li>
                                <li>Вставьте ваш ключ в поле <strong>"Ключ(и) API Google AI"</strong>.</li>
                                <li>(Рекомендуется) Установите флажок <strong>"Сохранить все настройки в этом браузере"</strong>, чтобы безопасно сохранить ваш ключ для будущего использования.</li>
                            </ol>
                        </div>
                        <div>
                            <h3 class="text-lg font-bold mb-2 text-slate-800 dark:text-slate-100">2. Перевод контента</h3>
                            <p class="mb-3">Выберите желаемый тип ввода в верхнем меню: <strong>Текст, Изображение, PDF или Субтитры</strong>.</p>
                            <div class="space-y-4 pl-4 border-l-2 dark:border-slate-600">
                                <div>
                                    <h4 class="font-semibold">📝 Перевод текста</h4>
                                    <p>Выберите исходный и целевой языки, введите текст и нажмите <strong>Перевести</strong>. Используйте кнопки <strong>Улучшить</strong> и <strong>Изменить стиль</strong> для доработки результата.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">🖼️ Перевод изображений</h4>
                                    <p>Выберите вкладку <strong>Изображение</strong>, укажите целевой язык и перетащите файл изображения. Приложение выполнит OCR для извлечения текста, а затем переведет его.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">📄 Перевод PDF</h4>
                                    <p>Загрузите PDF. Нажмите на страницы, которые вы хотите перевести. Для сканированных PDF включите опцию <strong>"Использовать OCR"</strong> в Расширенных настройках. Нажмите <strong>Перевести</strong>.</p>
                                </div>
                                <div>
                                    <h4 class="font-semibold">🎬 Перевод субтитров</h4>
                                    <p class="mb-2">Вы можете загрузить файл субтитров (SRT, VTT и т.д.) или вставить URL-адрес YouTube и нажать <strong>Получить</strong>, чтобы загрузить субтитры в редактор.</p>
                                    <ul class="list-disc list-inside space-y-1">
                                        <li><strong>Перевести все:</strong> Нажмите, чтобы перевести все строки пакетами.</li>
                                        <li><strong>Редактировать:</strong> Нажмите прямо на переведенный текст, чтобы отредактировать его вручную.</li>
                                        <li><strong>Инструменты:</strong> Используйте инструменты "Найти и заменить" и "Разбить длинные строки" для расширенного редактирования.</li>
                                        <li><strong>Экспорт:</strong> Нажмите кнопку экспорта в заголовке редактора, чтобы скачать переведенный файл.</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>`
            };
            // --- END: CONFIGURATION & I18N ---
        
            // --- START: DOM Element Selection ---
            const dom = {
                html: document.documentElement,
                form: document.getElementById('translate-form'),
                inputTypeRadios: document.querySelectorAll('input[name="input_type"]'),
                textInputContainer: document.getElementById('text-input-container'),
                youtubeInputSection: document.getElementById('youtube-input-section'),
                youtubeUrlInput: document.getElementById('youtube-url-input'),
                youtubeLangInput: document.getElementById('youtube-lang-input'),
                fetchYoutubeSubsBtn: document.getElementById('fetch-youtube-subs-btn'),
                fetchYoutubeBtnText: document.getElementById('fetch-youtube-btn-text'),
                fetchYoutubeBtnSpinner: document.getElementById('fetch-youtube-btn-spinner'),
                fileInputSection: document.getElementById('file-input-section'),
                dropzoneContainer: document.getElementById('dropzone-container'),
                dropzonePrompt: document.getElementById('dropzone-prompt'),
                filePreviewContainer: document.getElementById('file-preview-container'),
                imagePreview: document.getElementById('image-preview'),
                subtitlePreview: document.getElementById('subtitle-preview'),
                subtitleFilename: document.getElementById('subtitle-filename'),
                removeFileBtn: document.getElementById('remove-file-btn'),
                chooseFileBtn: document.getElementById('choose-file-btn'),
                fileUpload: document.getElementById('file-upload'),
                fileUploadHint: document.getElementById('file-upload-hint'),
                pdfViewerSection: document.getElementById('pdf-viewer-section'),
                pdfPageViewer: document.getElementById('pdf-page-viewer'),
                pageSelectionCounter: document.getElementById('page-selection-counter'),
                batchWarning: document.getElementById('batch-warning'),
                combinePagesCheckbox: document.getElementById('combine-pages-checkbox'),
                selectAllPagesBtn: document.getElementById('select-all-pages-btn'),
                deselectAllPagesBtn: document.getElementById('deselect-all-pages-btn'),
                subtitleEditorSection: document.getElementById('subtitle-editor-section'),
                subtitleTableBody: document.getElementById('subtitle-table-body'),
                translateAllSubsBtn: document.getElementById('translate-all-subs-btn'),
                subtitleBatchSizeInput: document.getElementById('subtitle-batch-size'),
                textInput: document.getElementById('text-input'),
                sourceLangSelect: document.getElementById('source_lang'),
                targetLangSelect: document.getElementById('target_lang'),
                swapBtn: document.getElementById('swap-btn'),
                charCounter: document.getElementById('char-counter'),
                mainOutputSection: document.getElementById('main-output-section'),
                output: document.getElementById('output'),
                copyBtn: document.getElementById('copy-btn'),
                exportBtn: document.getElementById('export-btn'),
                exportTextBtn: document.getElementById('export-text-btn'),
                copyIconDefault: document.getElementById('copy-icon-default'),
                copyIconSuccess: document.getElementById('copy-icon-success'),
                enhancementsToolbar: document.getElementById('enhancements-toolbar'),
                translateBtn: document.getElementById('translate-btn'),
                translateBtnText: document.getElementById('translate-btn-text'),
                translateBtnSpinner: document.getElementById('translate-btn-spinner'),
                errorDisplay: document.getElementById('error-display'),
                settingsToggleBtn: document.getElementById('settings-toggle-btn'),
                settingsPanel: document.getElementById('settings-panel'),
                modelSelect: document.getElementById('model'),
                jobFieldSelect: document.getElementById('job_field'),
                translationToneSelect: document.getElementById('translation_tone'),
                customToneContainer: document.getElementById('custom-tone-container'),
                customToneInput: document.getElementById('custom-tone-input'),
                temperatureSlider: document.getElementById('temperature'),
                temperatureValue: document.getElementById('temperature-value'),
                requestDelayInput: document.getElementById('request_delay'),
                apiKeyInput: document.getElementById('api_key'),
                saveSettingsCheckbox: document.getElementById('save-settings-checkbox'),
                themeToggleBtn: document.getElementById('theme-toggle'),
                themeIconLight: document.getElementById('theme-icon-light'),
                themeIconDark: document.getElementById('theme-icon-dark'),
                useProxyCheckbox: document.getElementById('use-proxy-checkbox'),
                customProxyContainer: document.getElementById('custom-proxy-container'),
                customProxyInput: document.getElementById('custom-proxy-input'),
                useCustomPromptCheckbox: document.getElementById('use-custom-prompt-checkbox'),
                customPromptContainer: document.getElementById('custom-prompt-container'),
                customPromptInput: document.getElementById('custom-prompt-input'),
                pdfOcrCheckbox: document.getElementById('pdf-ocr-checkbox'),
                optimizePromptBtn: document.getElementById('optimize-prompt-btn'),
                optimizePromptBtnText: document.getElementById('optimize-prompt-btn-text'),
                optimizePromptSpinner: document.getElementById('optimize-prompt-spinner'),
                progressContainer: document.getElementById('progress-container'),
                progressLabel: document.getElementById('progress-label'),
                progressPercentage: document.getElementById('progress-percentage'),
                progressBarInner: document.getElementById('progress-bar-inner'),
                cancelTranslationBtn: document.getElementById('cancel-translation-btn'),
                logViewer: document.getElementById('log-viewer'),
                logToggle: document.getElementById('log-toggle'),
                logContent: document.getElementById('log-content'),
                logOutput: document.getElementById('log-output'),
                // Subtitle Editor Tools
                findReplaceToggleBtn: document.getElementById('find-replace-toggle-btn'),
                breakLinesToggleBtn: document.getElementById('break-lines-toggle-btn'),
                findReplacePanel: document.getElementById('find-replace-panel'),
                breakLinesPanel: document.getElementById('break-lines-panel'),
                findInput: document.getElementById('find-input'),
                replaceInput: document.getElementById('replace-input'),
                findCaseSensitive: document.getElementById('find-case-sensitive'),
                replaceAllBtn: document.getElementById('replace-all-btn'),
                breakLinesMaxChars: document.getElementById('break-lines-max-chars'),
                breakLinesApplyBtn: document.getElementById('break-lines-apply-btn'),
                // New Progress Saving elements
                savedProgressNotification: document.getElementById('saved-progress-notification'),
                loadProgressBtn: document.getElementById('load-progress-btn'),
                clearProgressBtn: document.getElementById('clear-progress-btn'),
                // I18N and How-to-use elements
                languageSwitcher: document.getElementById('language-switcher'),
                howToUseBtn: document.getElementById('how-to-use-btn'),
                howToUseModal: document.getElementById('how-to-use-modal'),
                howToUseContent: document.getElementById('how-to-use-content'),
                howToUseTitle: document.getElementById('how-to-use-title'),
                howToUseCloseBtn: document.getElementById('how-to-use-close-btn'),
            };
            
            // --- START: State Management ---
            let pdfDoc = null;
            let selectedPages = new Set();
            let currentFile = null;
            let currentFileHash = null;
            let subtitleData = null; // To store parsed subtitle data
            let translationAbortController = null;
            let activeApiKeys = [];
            let currentLanguage = 'en';
            let subtitleTranslationState = {
                startChunkIndex: 0,
                allChunks: [],
            };
            // --- END: State Management ---
        
            // --- START: I18N & Language Switching ---
            function setLanguage(lang) {
                currentLanguage = lang;
                const translations = TRANSLATIONS[lang];
                if (!translations) {
                    console.error(`No translations found for language: ${lang}`);
                    return;
                }
            
                // Set page direction and language
                dom.html.lang = lang;
                dom.html.dir = lang === 'fa' ? 'rtl' : 'ltr';
            
                // Update title
                document.title = translations.pageTitle;
            
                // Update text content
                document.querySelectorAll('[data-i18n-key]').forEach(el => {
                    const key = el.dataset.i18nKey;
                    const translation = translations[key];
                    if (translation) {
                         if ('i18nHtml' in el.dataset) {
                            el.innerHTML = translation;
                        } else {
                            el.textContent = translation;
                        }
                    }
                });
            
                // Update placeholders
                document.querySelectorAll('[data-i18n-placeholder-key]').forEach(el => {
                    const key = el.dataset.i18nPlaceholderKey;
                    if (translations[key]) {
                        el.placeholder = translations[key];
                    }
                });

                // Update titles/tooltips
                document.querySelectorAll('[data-i18n-title-key]').forEach(el => {
                    const key = el.dataset.i18nTitleKey;
                    if (translations[key]) {
                        el.title = translations[key];
                        el.setAttribute('aria-label', translations[key]);
                    }
                });
            
                // Repopulate selects
                populateSelect(dom.sourceLangSelect, LANGUAGES, dom.sourceLangSelect.value);
                populateSelect(dom.targetLangSelect, LANGUAGES, dom.targetLangSelect.value, opt => opt.value !== 'auto');
                populateSelect(dom.jobFieldSelect, JOB_FIELDS, dom.jobFieldSelect.value);
                populateSelect(dom.translationToneSelect, TONES, dom.translationToneSelect.value);
            
                // Update How-to-use modal content
                dom.howToUseContent.innerHTML = HOW_TO_USE_CONTENT[lang] || '';

                // Specific UI updates
                updatePageSelectionCounter();
                updateCharCounter();
                localStorage.setItem('fluentify_language_v1', lang);
                validateForm();
            }
        
            // --- START: Logging ---
            function log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                
                const timeEl = document.createElement('span');
                timeEl.className = 'log-timestamp';
                timeEl.textContent = `[${timestamp}]`;
                
                const msgEl = document.createElement('span');
                msgEl.className = `log-message ${type}`;
                msgEl.textContent = message;
                
                entry.appendChild(timeEl);
                entry.appendChild(msgEl);
                dom.logOutput.appendChild(entry);
                dom.logContent.scrollTop = dom.logContent.scrollHeight; // Auto-scroll
            }
        
            // --- START: Core Translation Logic ---
            async function callGoogleAI(prompt, apiKey, model, useProxy, customProxyUrl, signal, temperature = 0.7) {
                log(`Calling Google AI model: ${model}...`);
                const directUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                const targetUrl = useProxy ? (customProxyUrl.trim() || DEFAULT_PROXY_URL) : directUrl;
                let payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    safetySettings: [{ category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }],
                    generationConfig: { 
                        responseMimeType: "text/plain",
                        temperature: parseFloat(temperature)
                    }
                };
                if (useProxy) { payload = { endpoint: directUrl, ...payload }; }
                try {
                    const response = await fetch(targetUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal });
                    const responseBody = await response.json();
                    if (!response.ok) {
                        const errorDetails = responseBody?.error || { message: 'Unknown API error' };
                        console.error(`Google AI API Error (${response.status})`, errorDetails);
                        let userMessage = errorDetails.message.includes("API key not valid") ? "The provided Google AI API Key is invalid." : `API Error: ${errorDetails.message}`;
                        if (response.status === 429) userMessage = "API rate limit exceeded. Please try again later.";
                        throw new Error(userMessage);
                    }
                    const candidate = responseBody.candidates?.[0];
                    if (!candidate) {
                        const blockReason = responseBody.promptFeedback?.blockReason;
                        if (blockReason) throw new Error(`Request blocked due to safety settings: ${blockReason}`);
                        throw new Error("Invalid response structure from AI.");
                    }
                    if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
                        if (candidate.finishReason === "SAFETY") throw new Error(`Translation blocked for safety reasons.`);
                        log(`AI processing stopped unexpectedly: ${candidate.finishReason}`, 'warn');
                    }
                    const resultText = candidate.content?.parts?.[0]?.text?.trim() ?? "";
                    log('Successfully received response from AI.', 'success');
                    return resultText;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Translation was cancelled by the user.');
                    }
                    log(`API call failed: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async function callGoogleAIBatch(itemsToTranslate, sourceLang, targetLang, jobField, apiKey, model, useProxy, customProxyUrl, signal, temperature = 0.7) {
                log(`Starting batch translation for ${itemsToTranslate.length} lines...`);
                
                const useCustomPrompt = dom.useCustomPromptCheckbox.checked;
                const customPromptText = dom.customPromptInput.value.trim();
                let prompt;

                if (useCustomPrompt && customPromptText) {
                    log('Using custom prompt for batch subtitle translation.');
                    
                    let finalCustomPrompt = customPromptText
                        .replace(/\{source_lang\}/g, sourceLang === 'auto' ? 'the auto-detected language' : sourceLang)
                        .replace(/\{target_lang\}/g, targetLang);
                        
                    let translationInstruction;
                    if (finalCustomPrompt.includes('{text}')) {
                        translationInstruction = `The core instruction is: "${finalCustomPrompt.replace('{text}', 'the text to translate')}". You must apply this instruction to the "original" field of each JSON object.`;
                    } else {
                        translationInstruction = `${finalCustomPrompt}\nYour task is to translate the "original" field of each JSON object according to these instructions.`;
                    }
                    
                    prompt = `You are an expert translation model processing a batch request.
Your task is to translate a sequence of subtitle lines provided in a JSON array.

**Translation Instructions:**
${translationInstruction}

**Output Format:**
- You **MUST** return a JSON array of objects.
- Each object must contain the original "id" and a "translation" field with the translated text.
- The output array **MUST** have the exact same number of objects as the input array. Do not skip any IDs.
- Maintain conversational context and continuity between the lines in the batch.

Input JSON:
${JSON.stringify(itemsToTranslate)}`.trim();

                } else {
                    const jobFieldText = JOB_FIELDS.find(f => f.value === jobField)?.text || 'General';
                    const specializationContext = (jobField && jobField !== "None") ? `Pay close attention to specialized terms in the field of **${jobFieldText}**.` : "";
                    
                    let toneContext = '';
                    const selectedTone = dom.translationToneSelect.value;
                    const customToneText = dom.customToneInput.value.trim();
                    if (selectedTone === 'Custom' && customToneText) {
                        toneContext = `Adopt the following tone and style: "${customToneText}".`;
                    } else if (selectedTone !== 'Default' && selectedTone !== 'Custom') {
                        const toneInstructions = {
                            'Formal': 'Translate the text using a formal, professional tone.',
                            'Informal': 'Translate the text using a casual, informal, and friendly tone.',
                            'Poetic': 'Translate the text in a more poetic and artistic style. Use metaphors and evocative language where appropriate.',
                            'Technical': 'Translate the text with a technical and precise tone, ensuring accuracy for domain-specific terminology.',
                            'Simplify': 'Translate the text to be very simple and easy to understand, as if explaining it to a child.'
                        };
                        toneContext = toneInstructions[selectedTone] || '';
                    }

                    prompt = `You are an expert subtitle translator for videos.
Your task is to translate a sequence of subtitle lines.
Translate the "original" text for each JSON object in the input array from ${sourceLang === 'auto' ? 'the auto-detected language' : sourceLang} to **${targetLang}**.
${specializationContext}
${toneContext ? `${toneContext}` : ''}

**Crucially, you must maintain the conversational context and continuity between the lines.** The translation for one line should flow naturally from the previous line and into the next within the batch.

You **MUST** return a JSON array of objects. Each object must contain the original "id" and the "translation" of the text.
The output array **MUST** have the exact same number of objects as the input array. Do not skip any IDs.

Input JSON:
${JSON.stringify(itemsToTranslate)}`.trim();
                }
            
                const responseSchema = {
                    type: 'ARRAY',
                    items: {
                        type: 'OBJECT',
                        properties: {
                            id: { type: 'INTEGER' },
                            translation: { type: 'STRING' }
                        },
                        required: ['id', 'translation']
                    }
                };
            
                const directUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                const targetUrl = useProxy ? (customProxyUrl.trim() || DEFAULT_PROXY_URL) : directUrl;
                let payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    safetySettings: [{ category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }],
                    generationConfig: { 
                        responseMimeType: "application/json",
                        responseSchema: responseSchema,
                        temperature: parseFloat(temperature)
                    }
                };
                if (useProxy) { payload = { endpoint: directUrl, ...payload }; }
                
                try {
                    const response = await fetch(targetUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal });
                    const responseBody = await response.json();
                    if (!response.ok) {
                        const errorDetails = responseBody?.error || { message: 'Unknown API error' };
                        let userMessage = errorDetails.message.includes("API key not valid") ? "The provided Google AI API Key is invalid." : `API Error: ${errorDetails.message}`;
                        if (response.status === 429) userMessage = "API rate limit exceeded. Please try again later.";
                        throw new Error(userMessage);
                    }
                    const candidate = responseBody.candidates?.[0];
                    if (!candidate) {
                        const blockReason = responseBody.promptFeedback?.blockReason;
                        if (blockReason) throw new Error(`Request blocked due to safety settings: ${blockReason}`);
                        throw new Error("Invalid response structure from AI.");
                    }

                    if (candidate.finishReason === "MAX_TOKENS") {
                        throw new Error("The request was too large and the AI's response was cut short. Please reduce the 'Lines / Request' value in the Subtitle Editor and try again.");
                    }
                    
                    const responseText = candidate.content?.parts?.[0]?.text?.trim() ?? "";
                    const cleanedResponse = responseText.replace(/^```json\s*|```\s*$/g, '');
                    const translatedObjects = JSON.parse(cleanedResponse);

                    if (!Array.isArray(translatedObjects)) {
                        throw new Error("AI response was not a valid JSON array.");
                    }
                    
                    const validatedObjects = [];
                    const inputIds = new Set(itemsToTranslate.map(item => item.id));
                    let processedCount = 0;

                    for (const item of translatedObjects) {
                        if (item && typeof item.id === 'number' && inputIds.has(item.id)) {
                             validatedObjects.push({
                                id: item.id,
                                translation: item.translation ?? null
                            });
                            processedCount++;
                        }
                    }

                    if (processedCount < itemsToTranslate.length) {
                         log(`Processed ${processedCount} of ${itemsToTranslate.length} lines. Some lines may not have been translated.`, 'warn');
                    } else {
                         log('Successfully received and processed batch translation.', 'success');
                    }
            
                    return validatedObjects;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Translation was cancelled by the user.');
                    }
                    log(`Batch API call failed: ${error.message}`, 'error');
                    if (error instanceof SyntaxError) {
                         throw new Error("The AI returned an invalid response format for batch translation.");
                    }
                    throw error;
                }
            }

            async function performOcr(base64Image, mimeType, apiKey, model, useProxy, customProxyUrl, signal) {
                log('Performing OCR on image...');
                const prompt = "Extract all text content from this image. Output ONLY the text found, preserving line breaks as accurately as possible. If no text is found, output nothing.";
                const promptParts = [{ text: prompt }, { inline_data: { mime_type: mimeType, data: base64Image } }];
                const directUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                const targetUrl = useProxy ? (customProxyUrl.trim() || DEFAULT_PROXY_URL) : directUrl;
                let payload = {
                    contents: [{ parts: promptParts }],
                    safetySettings: [{ category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },{ category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }],
                    generationConfig: { responseMimeType: "text/plain" }
                };
                if (useProxy) { payload = { endpoint: directUrl, ...payload }; }
                try {
                    const response = await fetch(targetUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal });
                    const responseBody = await response.json();
                    if (!response.ok) {
                        const errorDetails = responseBody?.error || { message: 'Unknown API error' };
                        let userMessage = errorDetails.message.includes("API key not valid") ? "The provided Google AI API Key is invalid." : `API Error: ${errorDetails.message}`;
                        throw new Error(userMessage);
                    }
                    const text = responseBody.candidates?.[0]?.content?.parts?.[0]?.text?.trim() ?? "";
                    log(text ? 'OCR completed successfully.' : 'OCR completed, but no text was found.', text ? 'success' : 'warn');
                    return text;
                } catch(error) {
                    if (error.name === 'AbortError') {
                        throw new Error('OCR was cancelled by the user.');
                    }
                    log(`OCR failed: ${error.message}`, 'error');
                    throw error;
                }
            }
        
            async function extractTextFromPdfPage(pageNumber, ocrOptions) {
                if (!pdfDoc) return null;
                const page = await pdfDoc.getPage(pageNumber);
                
                // 1. Try standard text extraction
                const textContent = await page.getTextContent();
                let extractedText = textContent.items.map(item => item.str).join(' ').trim();
                
                // 2. Check if OCR is needed and enabled
                const TEXT_THRESHOLD = 20; // If less than 20 chars, assume it's a scan
                if (ocrOptions.useOcr && extractedText.length < TEXT_THRESHOLD) {
                    log(`Page ${pageNumber} has little/no text. Attempting OCR...`, 'info');
                    try {
                        // 3. Render page to canvas
                        const viewport = page.getViewport({ scale: 1.5 }); // Use a decent scale for OCR quality
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        
                        // 4. Convert to base64
                        const base64Image = canvas.toDataURL('image/jpeg').split(',')[1];
                        
                        // 5. Perform OCR
                        const ocrText = await performOcr(
                            base64Image,
                            'image/jpeg',
                            ocrOptions.apiKey,
                            ocrOptions.model,
                            ocrOptions.useProxy,
                            ocrOptions.customProxyUrl,
                            ocrOptions.signal
                        );
                        return ocrText || "(OCR detected no text)"; // Return OCR text if available
                    } catch (error) {
                        log(`OCR failed for page ${pageNumber}: ${error.message}`, 'error');
                        // Fallback to the little text we found, or an error message
                        return extractedText || `(OCR failed for page ${pageNumber})`;
                    }
                }
                
                return extractedText; // Return standard extracted text
            }
            
            function getPrompt(text, sourceLang, targetLang, jobField, customPrompt) {
                if (dom.useCustomPromptCheckbox.checked && customPrompt && customPrompt.trim()) {
                    log('Using custom prompt.');
                    return customPrompt
                        .replace(/\{text\}/g, text)
                        .replace(/\{source_lang\}/g, sourceLang === 'auto' ? 'the auto-detected language' : sourceLang)
                        .replace(/\{target_lang\}/g, targetLang);
                }
                
                const jobFieldText = JOB_FIELDS.find(f => f.value === jobField)?.text || 'General';
                const specializationContext = (jobField && jobField !== "None") ? `Pay close attention to specialized terms in the field of **${jobFieldText}**.` : "";
                
                let toneContext = '';
                const selectedTone = dom.translationToneSelect.value;
                const customToneText = dom.customToneInput.value.trim();
                if (selectedTone === 'Custom' && customToneText) {
                    toneContext = `Adopt the following tone and style: "${customToneText}".`;
                } else if (selectedTone !== 'Default' && selectedTone !== 'Custom') {
                    const toneInstructions = {
                        'Formal': 'Translate the text using a formal, professional tone.',
                        'Informal': 'Translate the text using a casual, informal, and friendly tone.',
                        'Poetic': 'Translate the text in a more poetic and artistic style. Use metaphors and evocative language where appropriate.',
                        'Technical': 'Translate the text with a technical and precise tone, ensuring accuracy for domain-specific terminology.',
                        'Simplify': 'Translate the text to be very simple and easy to understand, as if explaining it to a child.'
                    };
                    toneContext = toneInstructions[selectedTone] || '';
                }

                return `
        You are an expert translator. Your task is to accurately translate the given text.
        - Maintain a natural, conversational tone suitable for the target language.
        - Ensure grammatical correctness and proper sentence structure.
        - Preserve the original context and meaning.
        - Use consistent terminology if technical terms are present.
        - Avoid literal, word-for-word translations that sound unnatural.
        - Return ONLY the translated text, with no extra commentary or explanations.
        ${specializationContext}
        ${toneContext ? `- ${toneContext}` : ''}
        Translate the following text from ${sourceLang === 'auto' ? 'the auto-detected language' : sourceLang} into **${targetLang}**:
        ---
        ${text}
        ---`.trim();
            }
            
            async function translateText(text, sourceLang, targetLang, jobField, apiKey, model, useProxy, customProxyUrl, signal, customPrompt = '', temperature = 0.7) {
                const prompt = getPrompt(text, sourceLang, targetLang, jobField, customPrompt);
                return callGoogleAI(prompt, apiKey, model, useProxy, customProxyUrl, signal, temperature);
            }
            async function enhanceText(text, action, targetLang, apiKey, model, useProxy, customProxyUrl, signal, temperature = 0.7) { let actionInstruction = ''; switch(action) { case 'shorten': actionInstruction = `You are a text editor. Make the following text more concise and to the point. Remove filler words but preserve the core meaning. Return ONLY the rewritten text, in ${targetLang}.`; break; case 'expand': actionInstruction = `You are a content writer. Expand on the following text. Add more detail, examples, or elaborate on the ideas to make it more comprehensive. Return ONLY the rewritten text, in ${targetLang}.`; break; case 'summarize': actionInstruction = `You are a summarization expert. Provide a concise summary of the following text, capturing the main points. Return ONLY the summary, in ${targetLang}.`; break; case 'formal': actionInstruction = `You are a language style expert. Rewrite the following text in a formal tone, suitable for a professional or academic setting. Preserve the original meaning. Return ONLY the rewritten text, in ${targetLang}.`; break; case 'informal': actionInstruction = `You are a language style expert. Rewrite the following text in a casual, informal, and friendly tone. Preserve the original meaning. Return ONLY the rewritten text, in ${targetLang}.`; break; case 'poetic': actionInstruction = `You are a creative writer. Rewrite the following text in a more poetic and artistic style. Use metaphors, vivid imagery, and evocative language, while preserving the original core meaning. Return ONLY the rewritten text, in ${targetLang}.`; break; case 'simplify': actionInstruction = `You are a language expert who specializes in simplification. Rewrite the following text to be very simple and easy to understand, as if explaining it to a child or someone new to the topic. Use basic vocabulary and short sentences. Preserve the original meaning. Return ONLY the rewritten text, in ${targetLang}.`; break; default: return text; } const prompt = `${actionInstruction}\n\n---\n${text}\n---`; return callGoogleAI(prompt, apiKey, model, useProxy, customProxyUrl, signal, temperature); }
            
            // --- START: Progress & Cancellation ---
            function showProgress(label) {
                dom.progressContainer.classList.remove('hidden');
                dom.progressLabel.textContent = label;
                updateProgress(0, 1);
            }
            function updateProgress(current, total) {
                const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
                dom.progressBarInner.style.width = `${percentage}%`;
                dom.progressPercentage.textContent = `${percentage}%`;
            }
            function hideProgress() {
                dom.progressContainer.classList.add('hidden');
            }
            function cancelTranslation() {
                if (translationAbortController) {
                    translationAbortController.abort();
                    log('Cancellation request sent.', 'warn');
                }
            }
        
            // --- START: PDF Smart Translation ---
            async function translatePdfPagesRecursively(pagesToTranslate, translationOptions) {
                const { signal } = translationOptions;
                if (signal.aborted) throw new Error("Translation was cancelled.");
                
                const combinedText = pagesToTranslate.map(p => p.text).join('\n\n');
                if (!combinedText.trim()) {
                    return pagesToTranslate.map(p => ({ pageNum: p.pageNum, translatedText: "(No text found or page is empty)" }));
                }
        
                try {
                    const translatedText = await translateText(combinedText, 'auto', translationOptions.targetLang, translationOptions.jobField, translationOptions.apiKey, translationOptions.model, translationOptions.useProxy, translationOptions.customProxyUrl, signal, dom.customPromptInput.value, translationOptions.temperature);
                    const pageNumbers = pagesToTranslate.map(p => p.pageNum).join('-');
                    return [{ pageNum: pageNumbers, translatedText: translatedText }];
                } catch (error) {
                    if (signal.aborted) throw error;
                    log(`Translating chunk of ${pagesToTranslate.length} pages failed. Splitting...`, 'warn');
                    
                    if (pagesToTranslate.length <= 1) {
                        const pageNum = pagesToTranslate[0]?.pageNum;
                        log(`Failed to translate page ${pageNum}. Skipping.`, 'error');
                        return [{ pageNum: pageNum, translatedText: `(Error: Translation failed for this page)` }];
                    }
        
                    const midPoint = Math.ceil(pagesToTranslate.length / 2);
                    const firstHalf = pagesToTranslate.slice(0, midPoint);
                    const secondHalf = pagesToTranslate.slice(midPoint);
        
                    const firstHalfResult = await translatePdfPagesRecursively(firstHalf, translationOptions);
                    
                    const delay = parseFloat(dom.requestDelayInput.value) * 1000 || 2000;
                    log(`Waiting for ${delay}ms before next chunk...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
        
                    const secondHalfResult = await translatePdfPagesRecursively(secondHalf, translationOptions);
                    
                    return [...firstHalfResult, ...secondHalfResult];
                }
            }
        
            // --- START: Subtitle Parsers & Editor ---
            function parseSrt(data) {
                const lines = [];
                // Normalize newlines to \n and split into blocks. This is more robust than a single complex regex.
                const blocks = data.trim().replace(/\r\n/g, '\n').split(/\n\n+/);

                for (const block of blocks) {
                    const blockLines = block.split('\n');
                    if (blockLines.length < 2) continue; // A block needs at least timecode and text.

                    let lineIndex = 0;
                    // Use a simple incrementing ID if the file doesn't have one or it's malformed.
                    let id = lines.length + 1;

                    // Check if the first line is a numeric ID.
                    if (/^\d+$/.test(blockLines[0].trim())) {
                        // We'll use our own incrementing ID for consistency, but we need to skip this line.
                        lineIndex = 1;
                    }

                    const timecodeLine = blockLines[lineIndex];
                    if (!timecodeLine || !timecodeLine.includes('-->')) continue;

                    // A more lenient timecode regex to handle variations.
                    const timeMatch = timecodeLine.match(/(\d{1,2}:\d{2}:\d{2}[,.]\d{1,3})\s*-->\s*(\d{1,2}:\d{2}:\d{2}[,.]\d{1,3})/);
                    if (!timeMatch) continue;

                    const text = blockLines.slice(lineIndex + 1).join('\n').trim();
                    if (!text) continue; // Skip empty subtitle blocks
                    
                    lines.push({
                        id: id, // Use consistent, internal ID
                        startTime: timeMatch[1].replace('.', ','), // Standardize to comma
                        endTime: timeMatch[2].replace('.', ','),   // Standardize to comma
                        text: text
                    });
                }
                return { lines, type: 'srt' };
            }
            function reconstructSrt(parsedData, translatedLines) { return parsedData.lines.map((line, index) => `${line.id}\n${line.startTime} --> ${line.endTime}\n${translatedLines[index] || line.text}`).join('\n\n') + '\n\n'; }
            function parseVtt(data) { const blocks = data.trim().split(/\r?\n\r?\n/); const header = blocks.shift() || 'WEBVTT'; const lines = []; const timecodePattern = /(\d{2}:\d{2}:\d{2}\.\d{3}\s-->\s\d{2}:\d{2}:\d{2}\.\d{3}.*)/; for (const block of blocks) { const blockLines = block.split(/\r?\n/); const timecodeIndex = blockLines.findIndex(l => timecodePattern.test(l)); if (timecodeIndex !== -1) { const timecode = blockLines[timecodeIndex].match(timecodePattern)[1]; const text = blockLines.slice(timecodeIndex + 1).join('\n'); const [startTime, endTime] = timecode.split(' --> ')[0].split(' ')[0]; lines.push({ startTime: startTime.replace('.',','), endTime: endTime.replace('.',','), text, timecode }); } } return { header, lines, type: 'vtt' }; }
            function reconstructVtt(parsedData, translatedLines) { const body = parsedData.lines.map((line, index) => `${line.timecode}\n${translatedLines[index] || line.text}`).join('\n\n'); return `${parsedData.header}\n\n${body}`; }
            function parseSsaAss(data) { const sections = data.split(/\[(.*?)\]/); const result = { info: '', styles: '', events: { format: null, lines: [] }, type: 'ass' }; for (let i = 1; i < sections.length; i += 2) { const sectionName = sections[i].trim().toLowerCase(); const sectionContent = sections[i + 1].trim(); if (sectionName.startsWith('script info')) { result.info = sectionContent; } else if (sectionName.endsWith('styles')) { result.styles = sectionContent; } else if (sectionName === 'events') { const lines = sectionContent.split(/\r?\n/); const formatLine = lines.find(l => l.toLowerCase().startsWith('format:')); if (!formatLine) continue; result.events.format = formatLine; const formatFields = formatLine.split(':')[1].trim().split(',').map(f => f.trim()); const textIndex = formatFields.findIndex(f => f.toLowerCase() === 'text'); if (textIndex === -1) continue; lines.forEach(line => { if (line.toLowerCase().startsWith('dialogue:')) { const parts = line.split(','); const meta = parts.slice(0, textIndex).join(','); const text = parts.slice(textIndex).join(','); result.events.lines.push({ meta, text }); } }); } } return result; }
            function reconstructSsaAss(parsedData, translatedLines) { const eventsHeader = `[Events]\n${parsedData.events.format}\n`; const eventLines = parsedData.events.lines.map((line, index) => `Dialogue: ${line.meta},${translatedLines[index] || line.text}`).join('\n'); let scriptInfoSection = parsedData.info ? `[Script Info]\n${parsedData.info}\n\n` : ''; let stylesSection = parsedData.styles ? `[V4+ Styles]\n${parsedData.styles}\n\n` : ''; return `${scriptInfoSection}${stylesSection}${eventsHeader}${eventLines}`; }
            
            function rerenderSubtitleTable() {
                if (!subtitleData) return;
                const translatedTexts = Array.from(dom.subtitleTableBody.querySelectorAll('tr')).map(row => row.cells[3].textContent);
                processAndDisplaySubtitles(null, null, translatedTexts);
            }
            
            function processAndDisplaySubtitles(fileContent, fileName, preservedTranslations = null) {
                try {
                    if(fileContent) { // Parse new file
                        log(`Processing subtitle content from: ${fileName}`);
                        const fileExt = fileName.split('.').pop().toLowerCase();
                        let parser;
                        switch (fileExt) {
                            case 'srt': parser = parseSrt; break;
                            case 'vtt': parser = parseVtt; break;
                            case 'ass': case 'ssa': parser = parseSsaAss; break;
                            default: throw new Error(`Unsupported subtitle format: .${fileExt}`);
                        }
                        subtitleData = parser(fileContent);
                    }
                    
                    const lines = subtitleData.lines || subtitleData.events.lines;
                     if (!lines || lines.length === 0) {
                        throw new Error(`No subtitle entries found in the file.`);
                    }
                    log(`Rendering ${lines.length} subtitle entries.`);
                    dom.subtitleTableBody.innerHTML = ''; // Clear previous table data
                    
                    const fragment = document.createDocumentFragment();
                    lines.forEach((line, index) => {
                        const row = document.createElement('tr');
                        row.dataset.originalIndex = index;
                        let timestamp = '';
                        if (line.startTime && line.endTime) timestamp = `${line.startTime} --> ${line.endTime}`;
                        else if (line.timecode) timestamp = line.timecode;
                        else if (line.meta) timestamp = line.meta.split(',').slice(1,3).join(' -> ');
                        
                        row.innerHTML = `
                            <td class="text-center">${line.id || index + 1}</td>
                            <td>${timestamp}</td>
                            <td>${line.text.replace(/\n/g, '<br>')}</td>
                            <td class="translated-text" contenteditable="true">${preservedTranslations ? (preservedTranslations[index] || '') : ''}</td>
                            <td><button type="button" data-index="${index}" class="translate-sub-row-btn w-full px-2 py-1 text-xs rounded-md bg-white dark:bg-slate-600 border border-gray-300 dark:border-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700" data-i18n-key="subtitleTranslateRowBtn">Translate</button></td>
                        `;
                        fragment.appendChild(row);
                    });
                    dom.subtitleTableBody.appendChild(fragment);
                    
                    dom.subtitleEditorSection.classList.remove('hidden');
                    if (fileName) { // Only update file preview if it's a new file
                        dom.dropzonePrompt.classList.add('hidden');
                        dom.filePreviewContainer.classList.remove('hidden');
                        dom.subtitlePreview.classList.remove('hidden');
                        dom.imagePreview.classList.add('hidden');
                        dom.subtitleFilename.textContent = fileName;
                    }
                    validateForm();
                } catch(error) {
                     showError(error.message);
                    log(error.message, 'error');
                    resetFileInput();
                }
            }
            async function renderSubtitleEditor(file) {
                currentFile = file;
                const fileContent = await fileToString(file);
                currentFileHash = await calculateFileHash(file);
                
                const savedProgressRaw = localStorage.getItem(`fluentify_progress_${currentFileHash}`);
                dom.savedProgressNotification.classList.add('hidden');
                if (savedProgressRaw) {
                    try {
                        const savedProgress = JSON.parse(savedProgressRaw);
                        if (savedProgress && savedProgress.translations) {
                            dom.savedProgressNotification.classList.remove('hidden');
                        }
                    } catch (e) {
                        log('Could not parse saved progress.', 'warn');
                        localStorage.removeItem(`fluentify_progress_${currentFileHash}`);
                    }
                }
                
                processAndDisplaySubtitles(fileContent, file.name);
            }
            
            // --- START: UI and Event Handlers ---
            function populateSelect(selectElement, options, defaultValue, filter = () => true) { 
                const translations = TRANSLATIONS[currentLanguage];
                selectElement.innerHTML = options
                    .filter(filter)
                    .map(opt => `<option value="${opt.value}" ${opt.value === defaultValue ? 'selected' : ''}>${translations[opt.i18nKey] || opt.text}</option>`)
                    .join(''); 
            }
            function handleInputTypeChange() { const selectedType = document.querySelector('input[name="input_type"]:checked').value; const isTextMode = selectedType === 'text'; const isImageMode = selectedType === 'image'; const isPdfMode = selectedType === 'pdf'; const isSubtitleMode = selectedType === 'subtitle'; dom.textInputContainer.classList.toggle('hidden', !isTextMode); dom.fileInputSection.classList.toggle('hidden', !isImageMode && !isPdfMode && !isSubtitleMode); dom.youtubeInputSection.classList.toggle('hidden', !isSubtitleMode); dom.pdfViewerSection.classList.toggle('hidden', !isPdfMode); dom.subtitleEditorSection.classList.toggle('hidden', !isSubtitleMode); dom.mainOutputSection.classList.toggle('hidden', isSubtitleMode); dom.sourceLangSelect.disabled = !isTextMode; if (!isTextMode) dom.sourceLangSelect.value = 'auto'; if (isImageMode) { dom.fileUpload.accept = "image/png, image/jpeg, image/webp, image/gif"; dom.fileUploadHint.textContent = TRANSLATIONS[currentLanguage].fileHintImage; } else if (isPdfMode) { dom.fileUpload.accept = "application/pdf"; dom.fileUploadHint.textContent = TRANSLATIONS[currentLanguage].fileHintPDF; } else if (isSubtitleMode) { dom.fileUpload.accept = ".srt,.vtt,.ssa,.ass"; dom.fileUploadHint.textContent = TRANSLATIONS[currentLanguage].fileHintSubtitle; } resetFileInput(); }
            function resetFileInput() { dom.fileUpload.value = ''; dom.dropzonePrompt.classList.remove('hidden'); dom.filePreviewContainer.classList.add('hidden'); dom.imagePreview.src = ''; dom.subtitlePreview.classList.add('hidden'); dom.subtitleFilename.textContent = ''; dom.youtubeUrlInput.value = ''; currentFile = null; currentFileHash = null; dom.pdfViewerSection.classList.add('hidden'); dom.pdfPageViewer.innerHTML = ''; pdfDoc = null; selectedPages.clear(); dom.subtitleEditorSection.classList.add('hidden'); dom.subtitleTableBody.innerHTML = ''; subtitleData = null; dom.savedProgressNotification.classList.add('hidden'); subtitleTranslationState = { startChunkIndex: 0, allChunks: [] }; dom.translateAllSubsBtn.textContent = 'Translate All'; updatePageSelectionCounter(); validateForm(); clearOutput(); }
            function swapLanguages() { const sourceVal = dom.sourceLangSelect.value; const targetVal = dom.targetLangSelect.value; if (sourceVal === 'auto') return; dom.sourceLangSelect.value = targetVal; dom.targetLangSelect.value = sourceVal; validateForm(); if(dom.output.value) dom.output.dir = RTL_LANGUAGES.has(dom.targetLangSelect.value) ? 'rtl' : 'ltr'; }
            function validateForm() { const selectedType = document.querySelector('input[name="input_type"]:checked').value; let hasInput = false; if (selectedType === 'text') { hasInput = dom.textInput.value.trim().length > 0 && dom.textInput.value.length <= 5000; } else if (selectedType === 'image') { hasInput = currentFile !== null; } else if (selectedType === 'pdf') { hasInput = selectedPages.size > 0; } else if (selectedType === 'subtitle') { const hasSubs = subtitleData !== null && (subtitleData.lines?.length > 0 || subtitleData.events?.lines.length > 0); hasInput = hasSubs; dom.exportBtn.disabled = !hasSubs; dom.findReplaceToggleBtn.disabled = !hasSubs; dom.breakLinesToggleBtn.disabled = !hasSubs || subtitleData.type === 'ass'; } const isApiKeyValid = dom.apiKeyInput.value.trim().length > 0; dom.translateBtn.disabled = !hasInput || !isApiKeyValid || selectedType === 'subtitle'; dom.swapBtn.disabled = dom.sourceLangSelect.value === 'auto' || selectedType !== 'text'; }
            function updateCharCounter() { const isTextMode = document.querySelector('input[name="input_type"]:checked').value === 'text'; if (isTextMode) { const len = dom.textInput.value.length; dom.charCounter.textContent = `${len} / 5000`; dom.charCounter.classList.toggle('text-red-500', len > 5000); dom.charCounter.classList.toggle('dark:text-red-400', len > 5000); } else { dom.charCounter.textContent = ''; } }
            function showError(message) { dom.errorDisplay.textContent = message; }
            function clearOutput() { dom.output.value = ''; dom.copyBtn.disabled = true; dom.exportTextBtn.disabled = true; dom.enhancementsToolbar.classList.add('hidden', 'opacity-0', '-translate-y-2'); showError(''); }
            async function handleFileChange(event) { const file = event.target.files[0]; if (!file) { resetFileInput(); return; } log(`File selected: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`); const selectedType = document.querySelector('input[name="input_type"]:checked').value; if (file.size > 20 * 1024 * 1024) { showError("File size exceeds 20MB limit."); log("File size exceeds 20MB limit.", 'error'); resetFileInput(); return; } if (selectedType === 'image') { currentFile = file; dom.dropzonePrompt.classList.add('hidden'); dom.filePreviewContainer.classList.remove('hidden'); dom.subtitlePreview.classList.add('hidden'); dom.imagePreview.classList.remove('hidden'); dom.imagePreview.src = URL.createObjectURL(file); } else if (selectedType === 'pdf') { currentFile = file; dom.filePreviewContainer.classList.add('hidden'); dom.pdfViewerSection.classList.remove('hidden'); await renderPdf(file); } else if (selectedType === 'subtitle') { await renderSubtitleEditor(file); } validateForm(); }
            async function renderPdf(file) {
                try {
                    log('Loading PDF...');
                    dom.pdfPageViewer.innerHTML = '<div class="spinner w-8 h-8 text-sky-500 mx-auto col-span-full"></div>';
                    const typedarray = new Uint8Array(await file.arrayBuffer());
                    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js`;
                    pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
                    log(`PDF loaded with ${pdfDoc.numPages} pages.`, 'success');
                    dom.pdfPageViewer.innerHTML = '';
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const placeholder = entry.target;
                                const pageNum = parseInt(placeholder.dataset.pageNumber, 10);
                                createPdfPageView(pageNum).then(pageView => {
                                   placeholder.parentNode.replaceChild(pageView, placeholder);
                                });
                                observer.unobserve(placeholder);
                            }
                        });
                    }, { root: dom.pdfPageViewer, rootMargin: '200px' });
                    for (let i = 1; i <= pdfDoc.numPages; i++) {
                        const placeholder = document.createElement('div');
                        placeholder.className = "pdf-page-placeholder";
                        placeholder.style.minHeight = '300px'; 
                        placeholder.dataset.pageNumber = i;
                        dom.pdfPageViewer.appendChild(placeholder);
                        observer.observe(placeholder);
                    }
                } catch (error) {
                    console.error("Error rendering PDF:", error);
                    showError("Could not load or render the PDF file.");
                    log(`Failed to render PDF: ${error.message}`, 'error');
                    dom.pdfPageViewer.innerHTML = '<p class="text-center text-red-500 col-span-full">Failed to load PDF</p>';
                }
            }
            async function createPdfPageView(pageNum) {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.2 });
                const canvas = document.createElement('canvas');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                canvas.className = "w-full h-auto block";
                await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                const pageContainer = document.createElement('div');
                pageContainer.className = "pdf-page-item relative cursor-pointer border-2 border-slate-400 dark:border-slate-600 rounded-lg overflow-hidden bg-white";
                pageContainer.dataset.pageNumber = pageNum;
                pageContainer.title = `Page ${pageNum}`;
                if (selectedPages.has(pageNum)) pageContainer.classList.add('selected');
                const pageNumberLabel = document.createElement('div');
                pageNumberLabel.className = "absolute bottom-2 left-2 rtl:left-auto rtl:right-2 bg-black/60 text-white text-xs font-bold px-2 py-1 rounded";
                pageNumberLabel.textContent = `Page ${pageNum}`;
                pageContainer.appendChild(canvas);
                pageContainer.appendChild(pageNumberLabel);
                pageContainer.addEventListener('click', () => togglePageSelection(pageNum));
                return pageContainer;
            }
            function togglePageSelection(pageNumber) { const thumbElement = dom.pdfPageViewer.querySelector(`.pdf-page-item[data-page-number="${pageNumber}"]`); if (selectedPages.has(pageNumber)) { selectedPages.delete(pageNumber); thumbElement?.classList.remove('selected'); } else { selectedPages.add(pageNumber); thumbElement?.classList.add('selected'); } updatePageSelectionCounter(); validateForm(); }
            function updatePageSelectionCounter() { 
                const translations = TRANSLATIONS[currentLanguage];
                const count = selectedPages.size;
                dom.pageSelectionCounter.textContent = translations.pdfPageCounter.replace('{count}', count);

                const delay = parseFloat(dom.requestDelayInput.value) || 2; 
                const timeEstimate = Math.round(count * delay); 
                dom.batchWarning.textContent = count > 1 && !dom.combinePagesCheckbox.checked ? translations.pdfBatchWarning.replace('{seconds}', timeEstimate) : ''; 
            }
            
            async function handleFormSubmit(event) {
                event.preventDefault();
                if (dom.translateBtn.disabled) return;
                showError('');
                clearOutput();
                dom.translateBtn.disabled = true;
                dom.translateBtnText.classList.add('hidden');
                dom.translateBtnSpinner.classList.remove('hidden');
                translationAbortController = new AbortController();
                const { signal } = translationAbortController;
                const formData = new FormData(dom.form);
                const apiKey = dom.apiKeyInput.value.split('\n').map(k => k.trim()).filter(Boolean)[0];
                if (!apiKey) {
                    showError("An API Key is required.");
                    dom.translateBtnText.classList.remove('hidden');
                    dom.translateBtnSpinner.classList.add('hidden');
                    dom.translateBtn.disabled = false;
                    return;
                }
                const model = formData.get('model');
                const targetLang = formData.get('target_lang');
                const sourceLang = formData.get('source_lang');
                const jobField = formData.get('job_field');
                const inputType = formData.get('input_type');
                const useProxy = formData.get('use_proxy') === 'on';
                const customProxyUrl = formData.get('custom_proxy_url');
                const combinePages = formData.get('combine_pages') === 'on';
                const temperature = dom.temperatureSlider.value;
                
                try {
                    if (inputType === 'pdf') {
                        const sortedPages = Array.from(selectedPages).sort((a, b) => a - b);
                        log(`Starting translation for ${sortedPages.length} PDF pages.`);
                        showProgress(`${TRANSLATIONS[currentLanguage].progressLabelTranslating} ${sortedPages.length} pages...`);
                        dom.output.value = `Extracting text from ${sortedPages.length} pages...`;
                        const pageData = [];
                        const usePdfOcr = dom.pdfOcrCheckbox.checked;

                        for (const pageNum of sortedPages) {
                            if (signal.aborted) throw new Error("Translation was cancelled.");
                            const ocrOptions = {
                                useOcr: usePdfOcr,
                                apiKey,
                                model,
                                useProxy,
                                customProxyUrl,
                                signal
                            };
                            const pageText = await extractTextFromPdfPage(pageNum, ocrOptions);
                            pageData.push({ pageNum: pageNum, text: pageText || "" });
                            updateProgress(pageData.length, sortedPages.length * 2); // 50% for extraction
                        }
                        const translationOptions = { apiKey, model, targetLang, jobField, useProxy, customProxyUrl, signal, customPrompt: dom.customPromptInput.value, temperature };
                        log('Text extraction complete. Starting translation...');
                        const translatedPageChunks = await translatePdfPagesRecursively(pageData, translationOptions);
                        updateProgress(1, 1); // 100%
                        if (combinePages) {
                            dom.output.value = translatedPageChunks.map(p => p.translatedText).join('\n\n');
                        } else {
                            dom.output.value = translatedPageChunks.map(p => `--- PAGE ${p.pageNum} ---\n${p.translatedText}`).join('\n\n');
                        }
                    } else {
                        let textToTranslate;
                        if (inputType === 'text') {
                            textToTranslate = formData.get('text').trim();
                        } else if (inputType === 'image') {
                            if (!currentFile) throw new Error("Please select an image file.");
                            dom.output.value = 'Extracting text from image...';
                            const base64Image = await fileToBase64(currentFile);
                            textToTranslate = await performOcr(base64Image, currentFile.type, apiKey, model, useProxy, customProxyUrl, signal);
                            if (!textToTranslate) {
                                dom.output.value = "(No text detected in image)";
                                throw new Error("No text detected in image");
                            }
                        }
                        
                        dom.output.value = TRANSLATIONS[currentLanguage].progressLabelTranslating;
                        const translatedText = await translateText(textToTranslate, sourceLang, targetLang, jobField, apiKey, model, useProxy, customProxyUrl, signal, dom.customPromptInput.value, temperature);
                        dom.output.value = translatedText;
                    }
                    dom.output.dir = RTL_LANGUAGES.has(targetLang) ? 'rtl' : 'ltr';
                    if (dom.output.value) {
                        dom.copyBtn.disabled = false;
                        dom.exportTextBtn.disabled = false;
                        dom.enhancementsToolbar.classList.remove('hidden');
                        setTimeout(() => dom.enhancementsToolbar.classList.remove('opacity-0', '-translate-y-2'), 10);
                    }
                } catch (error) {
                    console.error("Translation failed:", error);
                    showError(error.message);
                    dom.output.value = '';
                } finally {
                    dom.translateBtnText.classList.remove('hidden');
                    dom.translateBtnSpinner.classList.add('hidden');
                    hideProgress();
                    validateForm();
                    translationAbortController = null;
                }
            }
        
            async function handleEnhancement(action) {
                const currentText = dom.output.value;
                if (!currentText) { showError("Nothing to enhance."); return; }
                showError('');
                const originalBtnText = {};
                dom.enhancementsToolbar.querySelectorAll('.enhancement-btn').forEach(btn => {
                    originalBtnText[btn.dataset.action] = btn.innerHTML;
                    btn.disabled = true;
                    if (btn.dataset.action === action) {
                        btn.innerHTML = '<div class="spinner w-4 h-4 mx-auto"></div>';
                    }
                });
                translationAbortController = new AbortController();
                const apiKey = dom.apiKeyInput.value.split('\n').map(k => k.trim()).filter(Boolean)[0];
                 if (!apiKey) { showError("An API Key is required."); return; }
                const model = dom.modelSelect.value;
                const useProxy = dom.useProxyCheckbox.checked;
                const customProxyUrl = dom.customProxyInput.value;
                const targetLang = dom.targetLangSelect.value;
                const temperature = dom.temperatureSlider.value;
                
                try {
                    const enhancedText = await enhanceText(currentText, action, targetLang, apiKey, model, useProxy, customProxyUrl, translationAbortController.signal, temperature);
                    dom.output.value = enhancedText;
                } catch (error) {
                    showError(error.message);
                    // Don't restore original text on failure, so user sees error and can try again without losing context.
                } finally {
                    dom.enhancementsToolbar.querySelectorAll('.enhancement-btn').forEach(btn => {
                        btn.disabled = false;
                        btn.innerHTML = originalBtnText[btn.dataset.action];
                    });
                    translationAbortController = null;
                }
            }
            
            // --- START: Local Storage and Settings ---
            const LS_SETTINGS_KEY = 'fluentify_settings_v7';
            function saveSettings() { if (!dom.saveSettingsCheckbox.checked) { localStorage.removeItem(LS_SETTINGS_KEY); return; } const settings = { apiKey: dom.apiKeyInput.value, model: dom.modelSelect.value, targetLang: dom.targetLangSelect.value, jobField: dom.jobFieldSelect.value, theme: dom.html.classList.contains('dark') ? 'dark' : 'light', useProxy: dom.useProxyCheckbox.checked, customProxyUrl: dom.customProxyInput.value, useCustomPrompt: dom.useCustomPromptCheckbox.checked, customPrompt: dom.customPromptInput.value, temperature: dom.temperatureSlider.value, requestDelay: dom.requestDelayInput.value, translationTone: dom.translationToneSelect.value, customTone: dom.customToneInput.value, pdfOcr: dom.pdfOcrCheckbox.checked, language: currentLanguage }; localStorage.setItem(LS_SETTINGS_KEY, JSON.stringify(settings)); }
            function loadSettings() { try { const savedSettings = localStorage.getItem(LS_SETTINGS_KEY); if (savedSettings) { const settings = JSON.parse(savedSettings); dom.apiKeyInput.value = settings.apiKey || ''; dom.modelSelect.value = settings.model || DEFAULT_WEB_MODEL; dom.targetLangSelect.value = settings.targetLang || 'English'; dom.jobFieldSelect.value = settings.jobField || 'None'; dom.translationToneSelect.value = settings.translationTone || 'Default'; dom.customToneInput.value = settings.customTone || ''; dom.customToneContainer.classList.toggle('hidden', dom.translationToneSelect.value !== 'Custom'); applyTheme(settings.theme || 'dark'); dom.useProxyCheckbox.checked = settings.useProxy || false; dom.customProxyInput.value = settings.customProxyUrl || DEFAULT_PROXY_URL; dom.useCustomPromptCheckbox.checked = settings.useCustomPrompt || false; dom.customPromptInput.value = settings.customPrompt || ''; dom.temperatureSlider.value = settings.temperature || 0.7; dom.temperatureValue.textContent = settings.temperature || 0.7; dom.requestDelayInput.value = settings.requestDelay || 4; dom.pdfOcrCheckbox.checked = settings.pdfOcr || false; dom.saveSettingsCheckbox.checked = true; currentLanguage = settings.language || 'en'; } else { const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches; applyTheme(prefersDark ? 'dark' : 'light'); dom.customProxyInput.value = DEFAULT_PROXY_URL; currentLanguage = navigator.language.startsWith('fa') ? 'fa' : (navigator.language.startsWith('ru') ? 'ru' : 'en'); } } catch (e) { console.error("Failed to load settings", e); localStorage.removeItem(LS_SETTINGS_KEY); } }
            
            // --- START: Theme Management ---
            function applyTheme(theme) { dom.html.classList.toggle('dark', theme === 'dark'); dom.themeIconLight.classList.toggle('hidden', theme === 'dark'); dom.themeIconDark.classList.toggle('hidden', theme !== 'dark'); }
            function toggleTheme() { const newTheme = dom.html.classList.contains('dark') ? 'light' : 'dark'; applyTheme(newTheme); saveSettings(); }
            
            // --- START: Helper Functions ---
            function fileToString(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsText(file); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(error); }); }
            function fileToBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result.split(',')[1]); reader.onerror = (error) => reject(error); }); }
            async function calculateFileHash(file) { const buffer = await file.arrayBuffer(); const hashBuffer = await crypto.subtle.digest('SHA-256', buffer); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); }
            function copyToClipboard() { if (!dom.output.value) return; navigator.clipboard.writeText(dom.output.value).then(() => { dom.copyIconDefault.classList.add('hidden'); dom.copyIconSuccess.classList.remove('hidden'); setTimeout(() => { dom.copyIconDefault.classList.remove('hidden'); dom.copyIconSuccess.classList.add('hidden'); }, 2000); }).catch(err => { console.error('Failed to copy text:', err); showError('Could not copy text.'); }); }
            function exportOutput() {
                const inputType = document.querySelector('input[name="input_type"]:checked').value;
                let content = dom.output.value;
                let filename = 'translation.txt';
        
                if (inputType === 'subtitle' && subtitleData) {
                    log('Reconstructing subtitle file for export...');
                    const translatedLines = Array.from(dom.subtitleTableBody.querySelectorAll('tr')).map(row => row.cells[3].textContent);
                    let reconstructor;
                    switch(subtitleData.type) {
                        case 'srt': reconstructor = reconstructSrt; break;
                        case 'vtt': reconstructor = reconstructVtt; break;
                        case 'ass': reconstructor = reconstructSsaAss; break;
                    }
                    if(reconstructor) {
                        content = reconstructor(subtitleData, translatedLines);
                        const originalName = (currentFile?.name || 'youtube_export').substring(0, (currentFile?.name || 'youtube_export').lastIndexOf('.'));
                        const ext = subtitleData.type;
                        filename = `${originalName}.translated.${ext}`;
                        log(`Exporting as ${filename}`, 'success');
                    } else {
                        log('Could not find reconstructor for subtitle format.', 'error');
                        return;
                    }
                }
                
                if (!content) return;
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }
            // --- START: YouTube Subtitle Helpers ---
            function parseVideoIdFromUrl(url) { const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/; const match = url.match(regex); return match ? match[1] : null; }
            function formatSrtTimestamp(totalSeconds) { const hours = Math.floor(totalSeconds / 3600), minutes = Math.floor((totalSeconds % 3600) / 60), seconds = Math.floor(totalSeconds % 60), milliseconds = Math.round((totalSeconds - Math.floor(totalSeconds)) * 1000); const pad = (num, len = 2) => String(num).padStart(len, '0'); return `${pad(hours)}:${pad(minutes)}:${pad(seconds)},${pad(milliseconds, 3)}`; }
            function generateSrtFromYT(subtitles) { return subtitles.map((line, index) => { const startSeconds = parseFloat(line.start); const endSeconds = startSeconds + parseFloat(line.dur); const startTime = formatSrtTimestamp(startSeconds); const endTime = formatSrtTimestamp(endSeconds); return `${index + 1}\n${startTime} --> ${endTime}\n${line.text}\n`; }).join('\n'); }
            
            async function handleFetchYouTubeSubs() {
                const url = dom.youtubeUrlInput.value;
                const videoId = parseVideoIdFromUrl(url);
                const langCode = dom.youtubeLangInput.value.trim();

                if (!videoId) { showError('Invalid YouTube URL. Please check and try again.'); return; }
                if (!langCode) { showError('Please enter a language code (e.g., "en").'); return; }

                dom.fetchYoutubeBtnText.classList.add('hidden');
                dom.fetchYoutubeBtnSpinner.classList.remove('hidden');
                dom.fetchYoutubeSubsBtn.disabled = true;
                resetFileInput();

                try {
                    const targetApiUrl = `https://youtube-caption-extractor.vercel.app/api/videoDetails?videoID=${videoId}&lang=${langCode}`;
                    const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(targetApiUrl)}`;
                    log(`Fetching YouTube subtitles via: ${targetApiUrl}`);
                    
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);

                    const proxyData = await response.json();
                    if (!proxyData) throw new Error('Empty response from proxy.');

                    // The original code `JSON.parse(proxyData)` would fail because `response.json()` already returns an object.
                    // This change handles both cases gracefully: if the API returns a stringified JSON or a direct object.
                    const data = (typeof proxyData === 'string') ? JSON.parse(proxyData) : proxyData;
                    const details = data.videoDetails;

                    if (data.error || !details || !details.subtitles || details.subtitles.length === 0) {
                        throw new Error(`No subtitles found for language code "${langCode}". The code might be incorrect or the language unavailable.`);
                    }
                    
                    log(`Successfully fetched ${details.subtitles.length} lines for video: ${details.title}`, 'success');
                    const srtContent = generateSrtFromYT(details.subtitles);
                    const fileName = `${details.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.srt`;
                    
                    // Create a mock file object and render the editor
                    const mockFile = new File([srtContent], fileName, { type: 'text/plain' });
                    await renderSubtitleEditor(mockFile);

                } catch (error) {
                    let errorMessage = error.message;
                    if (error instanceof SyntaxError) { errorMessage = 'Failed to parse API response. The API or proxy may be down.'; }
                    showError(errorMessage);
                    log(errorMessage, 'error');
                } finally {
                    dom.fetchYoutubeBtnText.classList.remove('hidden');
                    dom.fetchYoutubeBtnSpinner.classList.add('hidden');
                    dom.fetchYoutubeSubsBtn.disabled = false;
                }
            }
            
            // --- START: Subtitle Editor Tools ---
            function highlightMatchesInSubtitles() {
                const findText = dom.findInput.value;
                const isCaseSensitive = dom.findCaseSensitive.checked;
                const flags = isCaseSensitive ? 'g' : 'gi';
                const regex = new RegExp(findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
            
                dom.subtitleTableBody.querySelectorAll('td.translated-text').forEach(cell => {
                    // Restore original text before highlighting
                    const originalText = cell.textContent;
                    if (findText) {
                        cell.innerHTML = originalText.replace(regex, match => `<mark>${match}</mark>`);
                    } else {
                        cell.innerHTML = originalText; // Remove marks if search is empty
                    }
                });
            }

            function handleReplaceAllInSubtitles() {
                const findText = dom.findInput.value;
                if (!findText) {
                    showError("Please enter text to find.");
                    return;
                }
                const replaceText = dom.replaceInput.value;
                const isCaseSensitive = dom.findCaseSensitive.checked;
                const flags = isCaseSensitive ? 'g' : 'gi';
                const regex = new RegExp(findText, flags);
                let replacements = 0;
            
                dom.subtitleTableBody.querySelectorAll('td.translated-text').forEach(cell => {
                    if (cell.textContent.match(regex)) {
                        cell.textContent = cell.textContent.replace(regex, replaceText);
                        replacements++;
                    }
                });
                log(`Replaced ${replacements} instance(s).`, 'success');
                dom.findInput.value = ''; // Clear find input to remove highlights
                highlightMatchesInSubtitles();
                saveCurrentSubtitleProgress();
            }

            function timeToMs(time) { const parts = time.split(/[:,.]/); return parseInt(parts[0], 10) * 3600000 + parseInt(parts[1], 10) * 60000 + parseInt(parts[2], 10) * 1000 + parseInt(parts[3], 10); }
            function msToTime(ms, isVTT) { const d = new Date(ms); const pad = (n) => n.toString().padStart(2, '0'); const padMs = (n) => n.toString().padStart(3, '0'); const separator = isVTT ? '.' : ','; return `${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:${pad(d.getUTCSeconds())}${separator}${padMs(d.getUTCMilliseconds())}`; }

            function handleBreakLongLines() {
                if (!subtitleData || !subtitleData.lines) return;
                if (!confirm('This will permanently modify your subtitle data by splitting long lines. This action cannot be undone. Are you sure?')) return;

                const maxLength = parseInt(dom.breakLinesMaxChars.value, 10);
                if (isNaN(maxLength) || maxLength < 10) {
                    showError("Max characters must be a number greater than 10.");
                    return;
                }

                log(`Breaking lines longer than ${maxLength} characters...`);
                // First, sync any manual edits from the DOM to subtitleData
                const translatedLines = Array.from(dom.subtitleTableBody.querySelectorAll('tr')).map(row => row.cells[3].textContent);

                const newLines = [];
                const isVTT = subtitleData.type === 'vtt';
                let hasChanges = false;

                subtitleData.lines.forEach((line, index) => {
                    const currentTranslatedText = translatedLines[index] || '';
                    if (currentTranslatedText.length <= maxLength) {
                        newLines.push({ ...line, translatedText: currentTranslatedText }); // Pass through
                        return;
                    }

                    const startMs = timeToMs(line.startTime.replace(',', '.'));
                    const endMs = timeToMs(line.endTime.replace(',', '.'));
                    const durationMs = endMs - startMs;

                    if (durationMs < 1000) { // Don't split very short duration lines
                        newLines.push({ ...line, translatedText: currentTranslatedText });
                        return;
                    }
                    
                    hasChanges = true;
                    const words = currentTranslatedText.split(' ');
                    let currentLineText = '';
                    const chunks = [];
                    
                    words.forEach(word => {
                        if ((currentLineText + ' ' + word).trim().length > maxLength) {
                            chunks.push(currentLineText.trim());
                            currentLineText = word;
                        } else {
                            currentLineText = (currentLineText + ' ' + word).trim();
                        }
                    });
                    chunks.push(currentLineText.trim());

                    const chunkDuration = durationMs / chunks.length;
                    
                    chunks.forEach((chunk, chunkIndex) => {
                        const newStartMs = startMs + (chunkIndex * chunkDuration);
                        const newEndMs = newStartMs + chunkDuration;
                        newLines.push({
                            ...line, // Copy original data like text
                            startTime: msToTime(newStartMs, isVTT),
                            endTime: msToTime(newEndMs, isVTT),
                            id: null, // We'll renumber later
                            translatedText: chunk
                        });
                    });
                });

                if (!hasChanges) {
                    log('No lines needed to be split.', 'info');
                    return;
                }

                // Renumber IDs for SRT format
                if (subtitleData.type === 'srt') {
                    newLines.forEach((line, index) => { line.id = index + 1; });
                }

                subtitleData.lines = newLines.map(({ translatedText, ...rest }) => rest);
                const newTranslations = newLines.map(line => line.translatedText);

                log(`Split complete. Total lines are now ${newLines.length}. Re-rendering table.`);
                processAndDisplaySubtitles(null, null, newTranslations);
                saveCurrentSubtitleProgress();
            }

            function saveCurrentSubtitleProgress() {
                if (!currentFileHash || !subtitleData) return;
                const translatedLines = Array.from(dom.subtitleTableBody.querySelectorAll('tr')).map(row => row.cells[3].textContent);
                const progress = {
                    originalFileName: currentFile.name,
                    translations: translatedLines,
                };
                localStorage.setItem(`fluentify_progress_${currentFileHash}`, JSON.stringify(progress));
                log('Translation progress saved.', 'info');
            }
            
            // --- START: Initialization ---
            function initialize() {
                const promoBanner = document.getElementById('promo-banner');
                const closeBannerBtn = document.getElementById('close-banner-btn');
                if (promoBanner && closeBannerBtn) {
                    closeBannerBtn.addEventListener('click', () => {
                        promoBanner.style.display = 'none';
                    });
                }
                
                loadSettings();
                dom.languageSwitcher.value = currentLanguage;
                setLanguage(currentLanguage);

                populateSelect(dom.modelSelect, MODELS.map(m => ({ value: m, text: m, i18nKey: null })), DEFAULT_WEB_MODEL);
                handleInputTypeChange();
                dom.customProxyContainer.classList.toggle('hidden', !dom.useProxyCheckbox.checked);
                dom.customPromptContainer.classList.toggle('hidden', !dom.useCustomPromptCheckbox.checked);
                
                // Event Listeners
                dom.form.addEventListener('submit', handleFormSubmit);
                dom.inputTypeRadios.forEach(radio => radio.addEventListener('change', handleInputTypeChange));
                dom.swapBtn.addEventListener('click', swapLanguages);
                dom.copyBtn.addEventListener('click', copyToClipboard);
                dom.exportBtn.addEventListener('click', exportOutput);
                dom.exportTextBtn.addEventListener('click', exportOutput);
                dom.themeToggleBtn.addEventListener('click', toggleTheme);
                dom.fetchYoutubeSubsBtn.addEventListener('click', handleFetchYouTubeSubs);
                dom.chooseFileBtn.addEventListener('click', () => dom.fileUpload.click());
                dom.removeFileBtn.addEventListener('click', resetFileInput);
                dom.fileUpload.addEventListener('change', handleFileChange);
                ['dragover', 'drop'].forEach(eventName => dom.dropzoneContainer.addEventListener(eventName, e => e.preventDefault()));
                dom.dropzoneContainer.addEventListener('dragenter', () => dom.dropzoneContainer.classList.add('border-sky-500'));
                dom.dropzoneContainer.addEventListener('dragleave', () => dom.dropzoneContainer.classList.remove('border-sky-500'));
                dom.dropzoneContainer.addEventListener('drop', (e) => { dom.dropzoneContainer.classList.remove('border-sky-500'); if (e.dataTransfer.files.length) { dom.fileUpload.files = e.dataTransfer.files; dom.fileUpload.dispatchEvent(new Event('change')); } });
                dom.selectAllPagesBtn.addEventListener('click', () => { if (!pdfDoc) return; const allPageItems = dom.pdfPageViewer.querySelectorAll('.pdf-page-item, .pdf-page-placeholder'); for(let i = 1; i <= pdfDoc.numPages; i++) { selectedPages.add(i); allPageItems[i-1]?.classList.add('selected'); } updatePageSelectionCounter(); validateForm(); });
                dom.deselectAllPagesBtn.addEventListener('click', () => { selectedPages.clear(); dom.pdfPageViewer.querySelectorAll('.pdf-page-item.selected').forEach(thumb => thumb.classList.remove('selected')); updatePageSelectionCounter(); validateForm(); });
                dom.combinePagesCheckbox.addEventListener('change', updatePageSelectionCounter);
                dom.enhancementsToolbar.querySelectorAll('.enhancement-btn').forEach(btn => btn.addEventListener('click', () => handleEnhancement(btn.dataset.action)));
                [dom.textInput, dom.apiKeyInput, dom.sourceLangSelect, dom.targetLangSelect, dom.customProxyInput].forEach(el => el.addEventListener('input', validateForm));
                dom.textInput.addEventListener('input', updateCharCounter);
                dom.settingsToggleBtn.addEventListener('click', () => dom.settingsPanel.classList.toggle('hidden'));
                dom.useProxyCheckbox.addEventListener('change', (e) => dom.customProxyContainer.classList.toggle('hidden', !e.target.checked));
                dom.useCustomPromptCheckbox.addEventListener('change', (e) => dom.customPromptContainer.classList.toggle('hidden', !e.target.checked));
                dom.translationToneSelect.addEventListener('change', (e) => dom.customToneContainer.classList.toggle('hidden', e.target.value !== 'Custom'));
                dom.logToggle.addEventListener('click', () => dom.logViewer.classList.toggle('max-h-0'));
                dom.cancelTranslationBtn.addEventListener('click', cancelTranslation);
                dom.temperatureSlider.addEventListener('input', (e) => { dom.temperatureValue.textContent = e.target.value; });
                dom.requestDelayInput.addEventListener('input', updatePageSelectionCounter);

                // I18N and How-to-use Listeners
                dom.languageSwitcher.addEventListener('change', (e) => setLanguage(e.target.value));
                dom.howToUseBtn.addEventListener('click', () => dom.howToUseModal.classList.remove('hidden'));
                dom.howToUseCloseBtn.addEventListener('click', () => dom.howToUseModal.classList.add('hidden'));
                dom.howToUseModal.addEventListener('click', (e) => {
                    if (e.target === dom.howToUseModal) { // Close on overlay click
                        dom.howToUseModal.classList.add('hidden');
                    }
                });
        
                // Subtitle editor event delegation
                dom.subtitleTableBody.addEventListener('click', async (e) => {
                    if (e.target && e.target.classList.contains('translate-sub-row-btn')) {
                        const btn = e.target;
                        const index = btn.dataset.index;
                        const row = btn.closest('tr');
                        const originalText = (subtitleData.lines || subtitleData.events.lines)[index].text;
                        const targetCell = row.cells[3];
                        btn.disabled = true;
                        btn.innerHTML = `<svg class="spinner w-3 h-3 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 R>0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
                        try {
                             const apiKey = dom.apiKeyInput.value.split('\n').map(k => k.trim()).filter(Boolean)[0];
                            if (!apiKey) throw new Error("API Key is required.");
                            const translated = await translateText(originalText, 'auto', dom.targetLangSelect.value, dom.jobFieldSelect.value, apiKey, dom.modelSelect.value, dom.useProxyCheckbox.checked, dom.customProxyInput.value, null, dom.customPromptInput.value, dom.temperatureSlider.value);
                            targetCell.textContent = translated;
                            saveCurrentSubtitleProgress();
                        } catch(err) {
                            showError(err.message);
                            targetCell.textContent = 'Error!';
                        } finally {
                            btn.disabled = false;
                            btn.textContent = TRANSLATIONS[currentLanguage].subtitleTranslateRowBtn;
                        }
                    }
                });
                dom.subtitleTableBody.addEventListener('blur', (e) => {
                    if (currentFileHash && e.target.isContentEditable) {
                        saveCurrentSubtitleProgress();
                    }
                }, true); // Use capture to ensure it fires
                
                dom.translateAllSubsBtn.addEventListener('click', async () => {
                    const allKeys = dom.apiKeyInput.value.split('\n').map(k => k.trim()).filter(Boolean);
                    if (allKeys.length === 0) { showError("At least one API Key is required."); return; }
                    
                    const isResuming = subtitleTranslationState.startChunkIndex > 0;
                    if (!isResuming) {
                        activeApiKeys = [...allKeys];
                        const allRows = Array.from(dom.subtitleTableBody.querySelectorAll('tr'))
                            .map((row, index) => ({
                                row: row,
                                targetCell: row.cells[3],
                                originalText: (subtitleData.lines || subtitleData.events.lines)[index].text,
                                originalIndex: index
                            }));

                        const rowsToTranslate = allRows.filter(item => !item.targetCell.textContent.trim());
                        const totalToTranslate = rowsToTranslate.length;
                        if (totalToTranslate === 0) { log('All subtitles are already translated.', 'info'); return; }

                        const batchSize = parseInt(dom.subtitleBatchSizeInput.value, 10) || 250;
                        subtitleTranslationState.allChunks = [];
                        for (let i = 0; i < totalToTranslate; i += batchSize) {
                            subtitleTranslationState.allChunks.push(rowsToTranslate.slice(i, i + batchSize));
                        }
                    }

                    if (activeApiKeys.length === 0) {
                        showError("All API keys failed. Please add a valid key.");
                        return;
                    }

                    translationAbortController = new AbortController();
                    const { signal } = translationAbortController;
                    const totalChunks = subtitleTranslationState.allChunks.length;
                    const totalLines = subtitleTranslationState.allChunks.flat().length;
                    showProgress(`${TRANSLATIONS[currentLanguage].progressLabelTranslating} ${totalLines} subtitle lines...`);
                    dom.translateAllSubsBtn.disabled = true;
                    dom.translateAllSubsBtn.textContent = isResuming ? 'Resuming...' : TRANSLATIONS[currentLanguage].progressLabelTranslating;

                    let translatedInSession = 0;

                    try {
                        for (let i = subtitleTranslationState.startChunkIndex; i < totalChunks; i++) {
                            const chunk = subtitleTranslationState.allChunks[i];
                            if (signal.aborted) throw new Error("Translation was cancelled.");
                            
                            log(`Translating batch ${i + 1} of ${totalChunks} (${chunk.length} lines)...`);
                            const itemsToTranslate = chunk.map(item => ({ id: item.originalIndex, original: item.originalText }));
                            
                            let translatedObjects = null;
                            let success = false;
                            while(!success && activeApiKeys.length > 0) {
                                const currentApiKey = activeApiKeys[0];
                                try {
                                    translatedObjects = await callGoogleAIBatch(
                                        itemsToTranslate, 'auto', dom.targetLangSelect.value, dom.jobFieldSelect.value, currentApiKey, dom.modelSelect.value,
                                        dom.useProxyCheckbox.checked, dom.customProxyInput.value, signal, dom.temperatureSlider.value
                                    );
                                    success = true;
                                } catch (err) {
                                    if (err.message.includes("API key not valid")) {
                                        log(`API Key starting with "${currentApiKey.substring(0, 4)}..." failed. Removing from pool.`, 'warn');
                                        activeApiKeys.shift();
                                        if(activeApiKeys.length === 0) {
                                            throw new Error("All available API keys are invalid.");
                                        }
                                    } else {
                                        throw err; // Re-throw other errors
                                    }
                                }
                            }
                            
                            if (signal.aborted) throw new Error("Translation was cancelled.");
                            if (!translatedObjects) throw new Error("Translation failed for a batch.");

                            const translationMap = new Map(translatedObjects.map(item => [item.id, item.translation]));
                            chunk.forEach(item => {
                                const translatedText = translationMap.get(item.originalIndex);
                                if (translatedText !== null && translatedText !== undefined) {
                                    item.targetCell.textContent = translatedText;
                                } else { item.targetCell.textContent = '(Translation failed)'; }
                            });
                            
                            translatedInSession += chunk.length;
                            const totalTranslated = (subtitleTranslationState.allChunks.slice(0, i).flat().length) + translatedInSession;
                            updateProgress(totalTranslated, totalLines);
                            saveCurrentSubtitleProgress();

                            if (i < totalChunks - 1) {
                                const delay = parseFloat(dom.requestDelayInput.value) * 1000 || 2000;
                                log(`Waiting for ${delay}ms before next batch...`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                                if (signal.aborted) throw new Error("Translation was cancelled.");
                            }
                        }
                        log('Batch translation complete.', 'success');
                        subtitleTranslationState = { startChunkIndex: 0, allChunks: [] }; // Reset on success
                    } catch (err) {
                        subtitleTranslationState.startChunkIndex = Array.from(dom.subtitleTableBody.querySelectorAll('tr')).filter(r => r.cells[3].textContent.trim() === '').length > 0 ? subtitleTranslationState.startChunkIndex : 0;
                        showError(err.message);
                        dom.translateAllSubsBtn.textContent = 'Resume Translation';
                    } finally {
                        hideProgress();
                        translationAbortController = null;
                        dom.translateAllSubsBtn.disabled = false;
                        if (subtitleTranslationState.startChunkIndex === 0) {
                             dom.translateAllSubsBtn.textContent = TRANSLATIONS[currentLanguage].subtitleTranslateAll;
                        }
                    }
                });
        
                dom.optimizePromptBtn.addEventListener('click', async () => {
                    const currentPrompt = dom.customPromptInput.value;
                    if (!currentPrompt.trim()) { showError("Enter a prompt to optimize."); return; }
                    dom.optimizePromptBtnText.classList.add('hidden');
                    dom.optimizePromptSpinner.classList.remove('hidden');
                    dom.optimizePromptBtn.disabled = true;
                    try {
                        const metaPrompt = `You are a prompt engineering expert. Rewrite the following prompt to be clearer, more concise, and more effective for a large language model that performs translation. The prompt must include placeholders like {text}, {source_lang}, and {target_lang}. Return only the optimized prompt, without any commentary.
        ---
        ${currentPrompt}
        ---`;
                        const apiKey = dom.apiKeyInput.value.split('\n').map(k => k.trim()).filter(Boolean)[0];
                        if (!apiKey) throw new Error("API Key is required to optimize prompt.");
                        const optimizedPrompt = await callGoogleAI(metaPrompt, apiKey, dom.modelSelect.value, dom.useProxyCheckbox.checked, dom.customProxyInput.value, null, 0.5); // Use lower temp for optimization
                        dom.customPromptInput.value = optimizedPrompt;
                        log('Prompt optimized successfully.', 'success');
                    } catch (err) {
                        showError(err.message);
                    } finally {
                        dom.optimizePromptBtnText.classList.remove('hidden');
                        dom.optimizePromptSpinner.classList.add('hidden');
                        dom.optimizePromptBtn.disabled = false;
                    }
                });
        
                // Subtitle Editor Tools Listeners
                dom.findReplaceToggleBtn.addEventListener('click', () => dom.findReplacePanel.classList.toggle('hidden'));
                dom.breakLinesToggleBtn.addEventListener('click', () => dom.breakLinesPanel.classList.toggle('hidden'));
                dom.findInput.addEventListener('input', highlightMatchesInSubtitles);
                dom.findCaseSensitive.addEventListener('change', highlightMatchesInSubtitles);
                dom.replaceAllBtn.addEventListener('click', handleReplaceAllInSubtitles);
                dom.breakLinesApplyBtn.addEventListener('click', handleBreakLongLines);
                
                dom.loadProgressBtn.addEventListener('click', () => {
                     const savedProgressRaw = localStorage.getItem(`fluentify_progress_${currentFileHash}`);
                     if(savedProgressRaw) {
                         const savedProgress = JSON.parse(savedProgressRaw);
                         processAndDisplaySubtitles(null, null, savedProgress.translations);
                         dom.savedProgressNotification.classList.add('hidden');
                         log('Loaded saved progress.', 'success');
                     }
                });
                dom.clearProgressBtn.addEventListener('click', () => {
                     if (confirm('Are you sure you want to delete the saved progress for this file?')) {
                         localStorage.removeItem(`fluentify_progress_${currentFileHash}`);
                         dom.savedProgressNotification.classList.add('hidden');
                         log('Cleared saved progress.', 'info');
                     }
                });

                // Settings persistence
                [dom.apiKeyInput, dom.modelSelect, dom.targetLangSelect, dom.jobFieldSelect, dom.saveSettingsCheckbox, dom.useProxyCheckbox, dom.customProxyInput, dom.useCustomPromptCheckbox, dom.customPromptInput, dom.temperatureSlider, dom.requestDelayInput, dom.translationToneSelect, dom.customToneInput, dom.pdfOcrCheckbox, dom.languageSwitcher].forEach(el => {
                    const event = el.type === 'checkbox' || el.tagName === 'SELECT' || el.type === 'range' ? 'change' : 'input';
                    el.addEventListener(event, saveSettings);
                });
        
                log("Fluentify App Initialized.");
            }
            
            document.addEventListener('DOMContentLoaded', initialize);
        })();
        </script>

</body>
</html>
